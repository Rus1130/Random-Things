<style>
    body {
        cursor: crosshair;
    }
    #area {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
    }
    svg {
        overflow: visible;
    }
    #player {
        position: absolute;
        top: calc(50% - 33px);
        left: calc(50% - 26px);
        z-index: 1;
    }
    #healthbar {
        position: absolute;
        top: 2px;
        left: 26px;
        width: 300px;
        height: 50px;
        outline: 1px solid black;
        display: grid;
        grid-template-columns: repeat(20, 15px);
        grid-template-rows: 50px;
        z-index: -1;
    }
    #xpbar {
        position: absolute;
        top: 70px;
        left: 26px;
        width: 300px;
        height: 5px;
        outline: 1px solid black;
        z-index: -1;
    }
    #wave-counter {
        position: absolute;
        top: 25px;
        left: 330px;
        z-index: -1;
        font-size: 30px;

    }
    .health-pip {
        outline: 1px solid black;
        width: 15px;
        height: 50px;
        background-color: red;
    }
</style>
<head>

</head>
<body>
    <div id='healthbar'></div>
    <div id='xpbar'></div>
    <div id="wave-counter">Wave: 1</div>
    <div id="area">
        <svg width="50" id='player' height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect  width="50" height="50" fill="#FF0000"/>
            <rect x="24" y="24" id="cannonCenterer" width="2" height="2" fill="yellow"/>
            <g id="cannon">
                <rect x="16" y="18" width="50" height="15" fill="black"/>
            </g>
            <!--'<path d="M15 15H34.6078V35H15V15Z" fill="black"/>'-->
        </svg>
    </div>
</body>
<script>
    const area = document.getElementById('area');
    const player = document.getElementById('player');
    const heathbar = document.getElementById('healthbar');
    const xpBar = document.getElementById('xpbar');

    const enemies = {
        0: {
            wave: 1,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Grunt');
                gameData.currentWave++
            },
        },
        1: {
            wave: 2,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        2: {
            wave: 3,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        3: {
            wave: 4,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        4: {
            wave: 5,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        5: {
            wave: 6,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        6: {
            wave: 7,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        7: {
            wave: 8,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Grunt')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        8: {
            wave: 9,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Grunt')
                gameData.currentWave++
            },
        },
        9: {
            wave: 10,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                gameData.currentWave++
            },
        },
        10: {
            wave: 11,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                gameData.currentWave++
            },
        },
        11: {
            wave: 12,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                gameData.currentWave++
            },
        },
        12: {
            wave: 13,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Footman')
                spawnEnemy(i, 'Footman')
                gameData.currentWave++
            },
        },
        13: {
            wave: 14,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Footman')
                gameData.currentWave++
            },
        },
        14: {
            wave: 15,
            lock: false,
            lockFunction: function(i) {
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                spawnEnemy(i, 'Soldier')
                gameData.currentWave++
            },
        },
    }


    
    const gameData = {
        currentWave: 1,
        x: 0,
        y: 0,
        xVelocity: 0,
        yVelocity: 0,
        interval: null,
        up: 'w',
        down: 's',
        left: 'a',
        right: 'd',
        cannonAngle: 0,
        speed: 1,
        bulletSpeed: 0.9,
        friction: 0.95,
        xp: 0,
        xpToNextLevel: 10,
        level: 1,
        mouseX: 0,
        mouseX: 0,
        intervalLength: 1000/60,
        currentHealth: 20,
        maxHealth: 20,
        playing: true,
        waveStart: Date.now(),
        enemyCount: 0,
        enemyColors: {
            'Grunt': 'black',
            'Footman': 'blue',
            "Soldier": 'green',
        },
        oscillator: 0,
        oscillatorDirection: false,
    }

    function move(x, y){
        if(!gameData.playing) return;
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const newX = playerRect.left + x;
        const newY = playerRect.top + y;
        if(newX >= areaRect.left && newX <= areaRect.right - playerRect.width){
            player.style.left = newX + 'px';
        }
        if(newY >= areaRect.top && newY <= areaRect.bottom - playerRect.height){
            player.style.top = newY + 'px';
        }
    }


    function moveBullet(x, y, bullet){
        if(!gameData.playing) return;
        const bulletRect = bullet.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const newX = bulletRect.left + x;
        const newY = bulletRect.top + y;
        if(newX >= areaRect.left && newX <= areaRect.right - bulletRect.width){
            bullet.style.left = newX + 'px';
        }
        if(newY >= areaRect.top && newY <= areaRect.bottom - bulletRect.height){
            bullet.style.top = newY + 'px';
        }
    }

    function screenSetup(){
        const svgOutlines = {
            top: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            bottom: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            left: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            right: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
        }
        const outlineSize = 25;
        const outlineColor = 'white';

        svgOutlines.top.setAttribute('width', '100%');
        svgOutlines.top.setAttribute('height', `${outlineSize}px`);
        svgOutlines.top.setAttribute('fill', outlineColor);
        svgOutlines.top.setAttribute('x', '0');
        svgOutlines.top.setAttribute('y', '0');

        svgOutlines.bottom.setAttribute('width', '100%');
        svgOutlines.bottom.setAttribute('height', `${outlineSize}px`);
        svgOutlines.bottom.setAttribute('fill', outlineColor);
        svgOutlines.bottom.setAttribute('x', '0');
        svgOutlines.bottom.setAttribute('y', `calc(100% - ${outlineSize}px)`);

        svgOutlines.left.setAttribute('width', `${outlineSize}px`);
        svgOutlines.left.setAttribute('height', '100%');
        svgOutlines.left.setAttribute('fill', outlineColor);
        svgOutlines.left.setAttribute('x', '0');
        svgOutlines.left.setAttribute('y', '0');

        svgOutlines.right.setAttribute('width', `${outlineSize}px`);
        svgOutlines.right.setAttribute('height', '100%')
        svgOutlines.right.setAttribute('fill', outlineColor);
        svgOutlines.right.setAttribute('x', `calc(100% - ${outlineSize}px)`);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

        svg.style.zIndex = '-1';

        svg.appendChild(svgOutlines.top);
        svg.appendChild(svgOutlines.bottom);
        svg.appendChild(svgOutlines.left);
        svg.appendChild(svgOutlines.right);

        
        svgOutlines.top.setAttribute('collider', 'false');
        svgOutlines.bottom.setAttribute('collider', 'false');
        svgOutlines.left.setAttribute('collider', 'false');
        svgOutlines.right.setAttribute('collider', 'false');

        svg.style.position = 'absolute';
        svg.style.width = '100%';
        svg.style.height = '100%';

        area.appendChild(svg);
    }

    function healthbarSetup(){
        for(i = 0; i < gameData.maxHealth; i++){
            const heart = document.createElement('div');
            heart.id = `health-pip${i}`;
            heart.classList.add('health-pip');
            heathbar.appendChild(heart);
        }
    }


    window.addEventListener('resize', () => {
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        player.style.left = (areaRect.width / 2) - (playerRect.width / 2) + 'px';
        player.style.top = (areaRect.height / 2) - (playerRect.height / 2) + 'px';
        screenSetup()
    });

    function mouseController(e){
        if(!gameData.playing) return;
        document.addEventListener('mousemove', onMouseUpdate, false);
        document.addEventListener('mouseenter', onMouseUpdate, false);
            
        function onMouseUpdate(e) {
            gameData.mouseX = e.pageX;
            gameData.mouseY = e.pageY;
        }
    }

    // get all elements that have the property 'collideable'
    function getColliders(){
        const collideables = [];
        const allElements = document.getElementsByTagName('*');
        for(let i = 0; i < allElements.length; i++){
            if(allElements[i].hasAttribute('collider')){
                collideables.push(allElements[i]);
            }
        }
        return collideables;
    }

    function playerController(){
        if(!gameData.playing) return;
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const keys = {};
        const friction = 0.9;
        window.addEventListener('keydown', function(e){
            keys[e.key] = true;
        });
        window.addEventListener('keyup', function(e){
            keys[e.key] = false;
        });
        function movePlayer(){
            if(!gameData.playing) return;
            if(keys[gameData.up]){
                gameData.y -= gameData.speed;
            }
            if(keys[gameData.down]){
                gameData.y += gameData.speed;
            }
            if(keys[gameData.left]){
                gameData.x -= gameData.speed;
            }
            if(keys[gameData.right]){
                gameData.x += gameData.speed;
            }
            
            gameData.x *= friction;
            gameData.y *= friction;
            
            move(gameData.x, gameData.y);
        }

        function updateCannonAngle(){
            if(!gameData.playing) return;
            const cannon = document.getElementById('cannon');
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();
            const areaRect = area.getBoundingClientRect();
            const mouseX = gameData.mouseX;
            const mouseY = gameData.mouseY;
            const cannonCentererX = cannonCentererRect.left + (cannonCentererRect.width / 2);
            const cannonCentererY = cannonCentererRect.top + (cannonCentererRect.height / 2);
            const playerX = playerRect.left + (playerRect.width / 2);
            const playerY = playerRect.top + (playerRect.height / 2);
            const angle = Math.atan2(mouseY - cannonCentererY, mouseX - cannonCentererX) * 180 / Math.PI;
            gameData.cannonAngle = angle;
        }

        setInterval(updateCannonAngle, 1000/60);
        setInterval(mouseController, 1000/60);
        setInterval(movePlayer, 1000/60);
    }

    function rotate_point(pointX,pointY,originX,originY,angle) {
        angle = angle * Math.PI / 180.0;
        return {
            x: Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
            y: Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
        };
    }
    function cannonController(){
        function rotateCannon(){
            if(!gameData.playing) return;
            const player = document.getElementById('player');
            const playerRect = player.getBoundingClientRect();
            const cannon = document.getElementById('cannon');
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            const cannonRect = cannon.getBoundingClientRect();
            const cannonCentererX = cannonCentererRect.left + cannonCentererRect.width/2;
            const cannonCentererY = cannonCentererRect.top + cannonCentererRect.height/2;
            const mouseX = gameData.mouseX
            const mouseY = gameData.mouseY
            const angle = (Math.atan2(mouseY - cannonCentererY, mouseX - cannonCentererX)) * 180 / Math.PI;
            const newPoint = rotate_point(cannonRect.left, cannonRect.top, cannonCentererX, cannonCentererY, angle);

            cannon.style.transformOrigin = `${cannonCentererX - playerRect.left}px ${cannonCentererY - playerRect.top}px`;
            cannon.style.transform = `rotate(${gameData.cannonAngle}deg)`;
        }
       
        
        setInterval(rotateCannon, 1000/60);
    }

    // on click, create a bullet that is placed at the end of the barrel and moves in the direction of the cannon, and when it hits anything that is an svg, console log the id of the svg
    function bulletController(){
        window.addEventListener('click', function(e){
            // get the x and y coordinates of the end of the barrel
            if(!gameData.playing) return;
            const player = document.getElementById('player');
            const playerRect = player.getBoundingClientRect();
            const cannon = document.getElementById('cannon');
            const cannonRect = cannon.getBoundingClientRect();
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            // place the bullet in the center of the player
            const bullet = document.createElement('div');
            bullet.style.position = 'absolute';
            bullet.style.left = playerRect.left + playerRect.width/2 + 'px';
            bullet.style.top = playerRect.top + playerRect.height/2 + 'px';
            bullet.style.width = '10px';
            bullet.style.height = '10px';
            bullet.style.backgroundColor = 'black';
            bullet.style.borderRadius = '50%';
            area.appendChild(bullet);
            const angle = gameData.cannonAngle;
            const bulletData = {
                x: 0,
                y: 0,
                speed: 0.5,
                angle: angle,
                interval: null
            }
            function updateBulletPos(){
                if(!gameData.playing) return;
                bulletData.x += bulletData.speed * Math.cos(bulletData.angle * Math.PI / 180);
                bulletData.y += bulletData.speed * Math.sin(bulletData.angle * Math.PI / 180);
                moveBullet(bulletData.x, bulletData.y, bullet);
                // if the bullet hits an svg, console log the id of the svg
                const bulletRect = bullet.getBoundingClientRect();
                const areaRect = area.getBoundingClientRect();
                const svgElements = document.getElementsByTagName('svg');
                let colliders = getColliders();
                // if the bullet hits a collideables, remove the bullet
                for(let i = 0; i < colliders.length; i++){
                    const collideable = colliders[i];
                    const colliderRect = collideable.getBoundingClientRect();
                    if(bulletRect.left + bulletRect.width > colliderRect.left && bulletRect.left < colliderRect.left + colliderRect.width && bulletRect.top + bulletRect.height > colliderRect.top && bulletRect.top < colliderRect.top + colliderRect.height){
                        bullet.remove();
                        clearInterval(bulletData.interval);
                        // get attribute value
                        let attribute = collideable.getAttribute('collider');
                        if(attribute == 'true'){
                            let id = collideable.getAttribute('id').split('-')[0];
                            if(id == 'Grunt'){
                                addXp(2)
                            }
                            if(id == 'Footman'){
                                addXp(4)
                            }
                            collideable.remove();
                            gameData.enemyCount--;
                        }

                    }
                }
            }
            bulletData.interval = setInterval(updateBulletPos, 1000/60);
        });
    }

    function removeHeart(amnt){
        for(i = 0; i < amnt; i++){
            // remove the child
            const heart = document.getElementById(`health-pip${(gameData.currentHealth - 1) - i}`)
            heart.remove();
           
        }
        gameData.currentHealth -= amnt;
    }

    function gameoverController(){
        setInterval(function(){
            if(gameData.currentHealth <= 0){
                gameData.playing = false;
                alert('game over');
            }
        }, 1000/60);
    }

    function updateXPBar(){
        setInterval(function(){
            if(!gameData.playing) return;
            gameData.xpToNextLevel = Math.round(gameData.xpToNextLevel);
            xpBar.style.display = 'grid';
            xpBar.style.gridTemplateColumns = `repeat(${gameData.xpToNextLevel}, 1fr)`;
            for(let i = 0; i < gameData.xpToNextLevel; i++){
                if(!xpBar.children[i]){
                    const xpBarChild = document.createElement('div');
                    xpBarChild.id = `xpBarChild${i}`;
                    xpBarChild.style.backgroundColor = 'white';
                    xpBar.appendChild(xpBarChild);
                }
                if(gameData.xp > i){
                    xpBar.children[i].style.backgroundColor = 'black';
                }
            }
            if(gameData.xp >= gameData.xpToNextLevel){
                gameData.xp -= gameData.xpToNextLevel;
                gameData.xpToNextLevel *= 1.5;
                gameData.level++;
                for(let i = 0; i < xpBar.children.length; i++){
                    xpBar.children[i].style.backgroundColor = 'white';
                }
            }
        }, 1000/60);
    }

    function addXp(amnt){
        gameData.xp += amnt;
    }

    function spawnEnemy(i, enemyName){
        const enemy = document.createElement('div');
        enemy.style.position = 'absolute';
        // inclusive random number
        enemy.style.left = Math.random() * (area.getBoundingClientRect().width - 200) + 'px';
        enemy.style.top = Math.random() * (area.getBoundingClientRect().height - 200) + 'px';
        enemy.style.width = '20px';
        enemy.style.height = '20px';
        enemy.style.backgroundColor = gameData.enemyColors[enemyName];
        enemy.style.zIndex = '1';
        enemy.id = `${enemyName}-${i}`;
        enemy.setAttribute('collider', 'true');
        enemy.setAttribute('enemyName', enemyName);
        gameData.enemyCount++;
        area.appendChild(enemy);
    }

    function enemyController(){
        setInterval(function(){
            if(!gameData.playing) return;
            // excecute the lock functin in the enemy object when the current wave is equal to the wave the enemy is in
            for(let i = 0; i < Object.keys(enemies).length; i++){
                if(gameData.enemyCount == 0 && enemies[i].wave == gameData.currentWave){
                    if(!enemies[i].lock){
                        enemies[i].lock = true;
                        enemies[i].lockFunction(i);
                    }
                }
            }
            gruntController();
            footmanController();
            soldierController();
        }, 1000/60);
    }

    function enemyTemplate(enemyName, fn){
        if(!gameData.playing) return;
        let playerX = player.getBoundingClientRect().left;
        let playerY = player.getBoundingClientRect().top;
        let enemyList = document.querySelectorAll(`[enemyName="${enemyName}"]`);
        for(let i = 0; i < enemyList.length; i++){
            let enemyX = enemyList[i].getBoundingClientRect().left;
            let enemyY = enemyList[i].getBoundingClientRect().top;
            // run the function in the parameter
            fn(playerX, playerY, enemyX, enemyY, i);
        }
    }

    // make the grunt enemies follow the player
    
    function gruntController(){
        enemyTemplate('Grunt', function(){
            let playerX = arguments[0];
            let playerY = arguments[1];
            let enemyX = arguments[2];
            let enemyY = arguments[3];
            let i = arguments[4];
            // get all the enemies
            let enemyList = document.querySelectorAll('[enemyName="Grunt"]');
            if(enemyList[i].id.split('-')[0] == 'Grunt'){
                // move randomly if it is 200 pixels away from the player (cooldown of 1000 ms before switching directions)
                if(Math.abs(enemyX - playerX) > 300 || Math.abs(enemyY - playerY) > 300){
                    if(!enemyList[i].cooldown){
                        enemyList[i].cooldown = true;
                        enemyList[i].direction = Math.floor(Math.random() * 4);
                        setTimeout(function(){
                            enemyList[i].cooldown = false;
                        }, 1000);
                    }
                    if(enemyList[i].direction == 0){
                        enemyList[i].style.left = enemyX + 1 + 'px';
                    }
                    if(enemyList[i].direction == 1){
                        enemyList[i].style.left = enemyX - 1 + 'px';
                    }
                    if(enemyList[i].direction == 2){
                        enemyList[i].style.top = enemyY + 1 + 'px';
                    }
                    if(enemyList[i].direction == 3){
                        enemyList[i].style.top = enemyY - 1 + 'px';
                    }
                } else {
                    // make it move towards the player
                    if(enemyX < playerX){
                        enemyList[i].style.left = enemyX + 1 + 'px';
                    }
                    if(enemyX > playerX){
                        enemyList[i].style.left = enemyX - 1 + 'px';
                    }
                    if(enemyY < playerY){
                        enemyList[i].style.top = enemyY + 1 + 'px';
                    }
                    if(enemyY > playerY){
                        enemyList[i].style.top = enemyY - 1 + 'px';
                    }
                }
            }
        })
    }

    function footmanController(){
        enemyTemplate('Footman', function(){
            let playerX = arguments[0];
            let playerY = arguments[1];
            let enemyX = arguments[2];
            let enemyY = arguments[3];
            let i = arguments[4];
            // get all the enemies
            let enemyList = document.querySelectorAll('[enemyName="Footman"]');
            if(enemyList[i].id.split('-')[0] == 'Footman'){
                if(enemyX < playerX){
                    enemyList[i].style.left = enemyX + 1 + 'px';
                }
                if(enemyX > playerX){
                    enemyList[i].style.left = enemyX - 1 + 'px';
                }
                if(enemyY < playerY){
                    enemyList[i].style.top = enemyY + 1 + 'px';
                }
                if(enemyY > playerY){
                    enemyList[i].style.top = enemyY - 1 + 'px';
                }
            }
        })
    }

    function soldierController(){
        enemyTemplate('Soldier', function(){
            let playerX = arguments[0];
            let playerY = arguments[1];
            let enemyX = arguments[2];
            let enemyY = arguments[3];
            let i = arguments[4];
            // get all the enemies
            let enemyList = document.querySelectorAll('[enemyName="Soldier"]');
            if(enemyList[i].id.split('-')[0] == 'Soldier'){
                if(enemyX < playerX && enemyX > playerX - 200){
                    enemyList[i].style.left = enemyX + 2 + 'px';
                }
                if(enemyX > playerX && enemyX < playerX + 200){
                    enemyList[i].style.left = enemyX - 2 + 'px';
                }
                if(enemyY < playerY && enemyY > playerY - 200){
                    enemyList[i].style.top = enemyY + 2 + 'px';
                }
                if(enemyY > playerY && enemyY < playerY + 200){
                    enemyList[i].style.top = enemyY - 2 + 'px';
                }


                
                if(enemyX < playerX && enemyX < playerX - 200){
                    enemyList[i].style.top = enemyY + gameData.oscillator + 'px';
                    enemyList[i].style.left = enemyX + 1 + 'px';
                }
                if(enemyX > playerX && enemyX > playerX + 200){
                    enemyList[i].style.top = enemyY - gameData.oscillator + 'px';
                    enemyList[i].style.left = enemyX - 1 + 'px';
                }
                if(enemyY < playerY && enemyY < playerY - 200){
                    enemyList[i].style.left = enemyX + gameData.oscillator + 'px';
                    enemyList[i].style.top = enemyY + 1 + 'px';
                }
                if(enemyY > playerY && enemyY > playerY + 200){
                    enemyList[i].style.left = enemyX - gameData.oscillator + 'px';
                    enemyList[i].style.top = enemyY - 1 + 'px';
                }
                
            }
        })
    }

    // if an enemy collides with the player, console log the enemy id
    function enemyCollisionController(){
        setInterval(function(){
            if(!gameData.playing) return;
            let enemies = document.querySelectorAll('[collider="true"]');
            for(let i = 0; i < enemies.length; i++){
                let enemyX = enemies[i].getBoundingClientRect().left;
                let enemyY = enemies[i].getBoundingClientRect().top;
                let enemyWidth = enemies[i].getBoundingClientRect().width;
                let enemyHeight = enemies[i].getBoundingClientRect().height;
                let playerX = player.getBoundingClientRect().left;
                let playerY = player.getBoundingClientRect().top;
                let playerWidth = player.getBoundingClientRect().width;
                let playerHeight = player.getBoundingClientRect().height;
                if(enemyX < playerX + playerWidth && enemyX + enemyWidth > playerX && enemyY < playerY + playerHeight && enemyY + enemyHeight > playerY){
                    removeHeart(1);
                    enemies[i].remove();
                    gameData.enemyCount--;
                }
                // if the enemy collides with the outer walls, stop it from moving
                if(enemyX < 0){
                    enemies[i].style.left = 0 + 'px';
                }
                if(enemyX + enemyWidth > gameData.width){
                    enemies[i].style.left = gameData.width - enemyWidth + 'px';
                }
                if(enemyY < 0){
                    enemies[i].style.top = 0 + 'px';
                }
                if(enemyY + enemyHeight > gameData.height){
                    enemies[i].style.top = gameData.height - enemyHeight + 'px';
                }
            }
        }, 1000/60);
    }

    // space key listener
    document.addEventListener('keydown', function(e){
        if(e.key == ' '){
            gameData.playing = !gameData.playing;
        }
    });

    setInterval(function(){
        if(gameData.oscillator == 8){
            gameData.oscillatorDirection = true;
        } else if(gameData.oscillator == -8){
            gameData.oscillatorDirection = false;
        }

        if(!gameData.oscillatorDirection){
            gameData.oscillator++;
        } else {
            gameData.oscillator--;
        }

        document.getElementById('wave-counter').innerHTML = `Wave: ${gameData.currentWave - 1}`;

    }, 1000/60);

    // 300000

    screenSetup();
    gameoverController();
    updateXPBar();
    healthbarSetup();
    bulletController();
    playerController();
    enemyController();
    cannonController();
    enemyCollisionController();
</script>