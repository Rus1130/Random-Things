<style>
    body {
        cursor: crosshair;
    }
    #area {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
    }
    svg {
        overflow: visible;
    }
    #player {
        position: absolute;
        top: calc(50% - 33px);
        left: calc(50% - 26px);
        z-index: 1;
    }
    #healthbar {
        position: absolute;
        top: 20x;
        left: 26px;
        width: 300px;
        height: 50px;
        outline: 1px solid black;
        display: grid;
        grid-template-columns: repeat(20, 15px);
        grid-template-rows: 50px;
        z-index: -1;
    }
    #xpbar {
        position: absolute;
        top: 70px;
        left: 26px;
        width: 300px;
        height: 5px;
        outline: 1px solid black;
        z-index: -1;
    }
    .health-pip {
        outline: 1px solid black;
        width: 15px;
        height: 50px;
        background-color: red;
    }
</style>
<head>

</head>
<body>
    <div id= 'healthbar'></div>
    <div id = 'xpbar'></div>
    <div id="area">
        <svg width="50" id='player' height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect  width="50" height="50" fill="#FF0000"/>
            <rect x="24" y="24" id="cannonCenterer" width="2" height="2" fill="yellow"/>
            <g id="cannon">
                <rect x="16" y="18" width="50" height="15" fill="black"/>
            </g>
            <!--'<path d="M15 15H34.6078V35H15V15Z" fill="black"/>'-->
        </svg>
    </div>
</body>
<script>
    const area = document.getElementById('area');
    const player = document.getElementById('player');
    const heathbar = document.getElementById('healthbar');
    const xpBar = document.getElementById('xpbar');

    const enemies = {
        0: {
            wave: 1,
            name: 'Grunt',
            lock: false,
            lockFunction: function(i) {
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                gameData.currentWave++
            },
        },
        1: {
            wave: 2,
            name: 'Grunt',
            lock: false,
            lockFunction: function(i) {
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                spawnGrunt(i)
                gameData.currentWave++
            },
        },
    }

    const gameData = {
        currentWave: 1,
        x: 0,
        y: 0,
        xVelocity: 0,
        yVelocity: 0,
        interval: null,
        up: 'w',
        down: 's',
        left: 'a',
        right: 'd',
        cannonAngle: 0,
        speed: 1,
        bulletSpeed: 0.9,
        friction: 0.95,
        xp: 0,
        xpToNextLevel: 10,
        level: 1,
        mouseX: 0,
        mouseX: 0,
        intervalLength: 1000/60,
        currentHealth: 20,
        maxHealth: 20,
        playing: true,
        waveStart: Date.now(),
        enemyCount: 0,
    }

    function move(x, y){
        if(!gameData.playing) return;
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const newX = playerRect.left + x;
        const newY = playerRect.top + y;
        if(newX >= areaRect.left && newX <= areaRect.right - playerRect.width){
            player.style.left = newX + 'px';
        }
        if(newY >= areaRect.top && newY <= areaRect.bottom - playerRect.height){
            player.style.top = newY + 'px';
        }
    }


    function moveBullet(x, y, bullet){
        if(!gameData.playing) return;
        const bulletRect = bullet.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const newX = bulletRect.left + x;
        const newY = bulletRect.top + y;
        if(newX >= areaRect.left && newX <= areaRect.right - bulletRect.width){
            bullet.style.left = newX + 'px';
        }
        if(newY >= areaRect.top && newY <= areaRect.bottom - bulletRect.height){
            bullet.style.top = newY + 'px';
        }
    }

    function screenSetup(){
        const svgOutlines = {
            top: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            bottom: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            left: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
            right: document.createElementNS('http://www.w3.org/2000/svg', 'rect'),
        }
        const outlineSize = 25;
        const outlineColor = 'white';

        svgOutlines.top.setAttribute('width', '100%');
        svgOutlines.top.setAttribute('height', `${outlineSize}px`);
        svgOutlines.top.setAttribute('fill', outlineColor);
        svgOutlines.top.setAttribute('x', '0');
        svgOutlines.top.setAttribute('y', '0');

        svgOutlines.bottom.setAttribute('width', '100%');
        svgOutlines.bottom.setAttribute('height', `${outlineSize}px`);
        svgOutlines.bottom.setAttribute('fill', outlineColor);
        svgOutlines.bottom.setAttribute('x', '0');
        svgOutlines.bottom.setAttribute('y', `calc(100% - ${outlineSize}px)`);

        svgOutlines.left.setAttribute('width', `${outlineSize}px`);
        svgOutlines.left.setAttribute('height', '100%');
        svgOutlines.left.setAttribute('fill', outlineColor);
        svgOutlines.left.setAttribute('x', '0');
        svgOutlines.left.setAttribute('y', '0');

        svgOutlines.right.setAttribute('width', `${outlineSize}px`);
        svgOutlines.right.setAttribute('height', '100%')
        svgOutlines.right.setAttribute('fill', outlineColor);
        svgOutlines.right.setAttribute('x', `calc(100% - ${outlineSize}px)`);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

        svg.style.zIndex = '-1';

        svg.appendChild(svgOutlines.top);
        svg.appendChild(svgOutlines.bottom);
        svg.appendChild(svgOutlines.left);
        svg.appendChild(svgOutlines.right);

        
        svgOutlines.top.setAttribute('collider', 'false');
        svgOutlines.bottom.setAttribute('collider', 'false');
        svgOutlines.left.setAttribute('collider', 'false');
        svgOutlines.right.setAttribute('collider', 'false');

        svg.style.position = 'absolute';
        svg.style.width = '100%';
        svg.style.height = '100%';

        area.appendChild(svg);
    }

    function healthbarSetup(){
        for(i = 0; i < gameData.maxHealth; i++){
            const heart = document.createElement('div');
            heart.id = `health-pip${i}`;
            heart.classList.add('health-pip');
            heathbar.appendChild(heart);
        }
    }


    window.addEventListener('resize', () => {
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        player.style.left = (areaRect.width / 2) - (playerRect.width / 2) + 'px';
        player.style.top = (areaRect.height / 2) - (playerRect.height / 2) + 'px';
        screenSetup()
    });

    function mouseController(e){
        if(!gameData.playing) return;
        document.addEventListener('mousemove', onMouseUpdate, false);
        document.addEventListener('mouseenter', onMouseUpdate, false);
            
        function onMouseUpdate(e) {
            gameData.mouseX = e.pageX;
            gameData.mouseY = e.pageY;
        }
    }

    // get all elements that have the property 'collideable'
    function getColliders(){
        const collideables = [];
        const allElements = document.getElementsByTagName('*');
        for(let i = 0; i < allElements.length; i++){
            if(allElements[i].hasAttribute('collider')){
                collideables.push(allElements[i]);
            }
        }
        return collideables;
    }

    function playerController(){
        if(!gameData.playing) return;
        const player = document.getElementById('player');
        const playerRect = player.getBoundingClientRect();
        const areaRect = area.getBoundingClientRect();
        const keys = {};
        const friction = 0.9;
        window.addEventListener('keydown', function(e){
            keys[e.key] = true;
        });
        window.addEventListener('keyup', function(e){
            keys[e.key] = false;
        });
        function movePlayer(){
            if(!gameData.playing) return;
            if(keys[gameData.up]){
                gameData.y -= gameData.speed;
            }
            if(keys[gameData.down]){
                gameData.y += gameData.speed;
            }
            if(keys[gameData.left]){
                gameData.x -= gameData.speed;
            }
            if(keys[gameData.right]){
                gameData.x += gameData.speed;
            }
            
            gameData.x *= friction;
            gameData.y *= friction;
            
            move(gameData.x, gameData.y);
        }

        function updateCannonAngle(){
            if(!gameData.playing) return;
            const cannon = document.getElementById('cannon');
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();
            const areaRect = area.getBoundingClientRect();
            const mouseX = gameData.mouseX;
            const mouseY = gameData.mouseY;
            const cannonCentererX = cannonCentererRect.left + (cannonCentererRect.width / 2);
            const cannonCentererY = cannonCentererRect.top + (cannonCentererRect.height / 2);
            const playerX = playerRect.left + (playerRect.width / 2);
            const playerY = playerRect.top + (playerRect.height / 2);
            const angle = Math.atan2(mouseY - cannonCentererY, mouseX - cannonCentererX) * 180 / Math.PI;
            gameData.cannonAngle = angle;
        }

        setInterval(updateCannonAngle, 1000/60);
        setInterval(mouseController, 1000/60);
        setInterval(movePlayer, 1000/60);
    }

    function rotate_point(pointX,pointY,originX,originY,angle) {
        angle = angle * Math.PI / 180.0;
        return {
            x: Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
            y: Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
        };
    }
    function cannonController(){
        function rotateCannon(){
            if(!gameData.playing) return;
            const player = document.getElementById('player');
            const playerRect = player.getBoundingClientRect();
            const cannon = document.getElementById('cannon');
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            const cannonRect = cannon.getBoundingClientRect();
            const cannonCentererX = cannonCentererRect.left + cannonCentererRect.width/2;
            const cannonCentererY = cannonCentererRect.top + cannonCentererRect.height/2;
            const mouseX = gameData.mouseX
            const mouseY = gameData.mouseY
            const angle = (Math.atan2(mouseY - cannonCentererY, mouseX - cannonCentererX)) * 180 / Math.PI;
            const newPoint = rotate_point(cannonRect.left, cannonRect.top, cannonCentererX, cannonCentererY, angle);

            cannon.style.transformOrigin = `${cannonCentererX - playerRect.left}px ${cannonCentererY - playerRect.top}px`;
            cannon.style.transform = `rotate(${gameData.cannonAngle}deg)`;
        }
       
        
        setInterval(rotateCannon, 1000/60);
        
    }

    // on click, create a bullet that is placed at the end of the barrel and moves in the direction of the cannon, and when it hits anything that is an svg, console log the id of the svg
    function bulletController(){
        window.addEventListener('click', function(e){
            // get the x and y coordinates of the end of the barrel
            if(!gameData.playing) return;
            const player = document.getElementById('player');
            const playerRect = player.getBoundingClientRect();
            const cannon = document.getElementById('cannon');
            const cannonRect = cannon.getBoundingClientRect();
            const cannonCenterer = document.getElementById('cannonCenterer');
            const cannonCentererRect = cannonCenterer.getBoundingClientRect();
            // place the bullet in the center of the player
            const bullet = document.createElement('div');
            bullet.style.position = 'absolute';
            bullet.style.left = playerRect.left + playerRect.width/2 + 'px';
            bullet.style.top = playerRect.top + playerRect.height/2 + 'px';
            bullet.style.width = '10px';
            bullet.style.height = '10px';
            bullet.style.backgroundColor = 'black';
            bullet.style.borderRadius = '50%';
            area.appendChild(bullet);
            const angle = gameData.cannonAngle;
            const bulletData = {
                x: 0,
                y: 0,
                speed: 0.5,
                angle: angle,
                interval: null
            }
            function updateBulletPos(){
                if(!gameData.playing) return;
                bulletData.x += bulletData.speed * Math.cos(bulletData.angle * Math.PI / 180);
                bulletData.y += bulletData.speed * Math.sin(bulletData.angle * Math.PI / 180);
                moveBullet(bulletData.x, bulletData.y, bullet);
                // if the bullet hits an svg, console log the id of the svg
                const bulletRect = bullet.getBoundingClientRect();
                const areaRect = area.getBoundingClientRect();
                const svgElements = document.getElementsByTagName('svg');
                let colliders = getColliders();
                // if the bullet hits a collideables, remove the bullet
                for(let i = 0; i < colliders.length; i++){
                    const collideable = colliders[i];
                    const colliderRect = collideable.getBoundingClientRect();
                    if(bulletRect.left + bulletRect.width > colliderRect.left && bulletRect.left < colliderRect.left + colliderRect.width && bulletRect.top + bulletRect.height > colliderRect.top && bulletRect.top < colliderRect.top + colliderRect.height){
                        bullet.remove();
                        clearInterval(bulletData.interval);
                        // get attribute value
                        let attribute = collideable.getAttribute('collider');
                        if(attribute == 'true'){
                            let id = collideable.getAttribute('id').split('-')[0];
                            if(id == 'Grunt'){
                                addXp(2)
                            }
                            if(id == 'Soldier'){
                                addXp(4)
                            }
                            collideable.remove();
                            gameData.enemyCount--;
                        }

                    }
                }
            }
            bulletData.interval = setInterval(updateBulletPos, 1000/60);
        });
    }

    function removeHeart(amnt){
        for(i = 0; i < amnt; i++){
            document.getElementById(`health-pip${(gameData.currentHealth - 1) - i}`).style.backgroundColor = 'white';
        }
        gameData.currentHealth -= amnt;
    }

    function gameoverController(){
        setInterval(function(){
            if(gameData.currentHealth <= 0){
                gameData.playing = false;
                alert('game over');
            }
        }, 1000/60);
    }

    function updateXPBar(){
        setInterval(function(){
            if(!gameData.playing) return;
            gameData.xpToNextLevel = Math.round(gameData.xpToNextLevel);
            xpBar.style.display = 'grid';
            xpBar.style.gridTemplateColumns = `repeat(${gameData.xpToNextLevel}, 1fr)`;
            for(let i = 0; i < gameData.xpToNextLevel; i++){
                if(!xpBar.children[i]){
                    const xpBarChild = document.createElement('div');
                    xpBarChild.id = `xpBarChild${i}`;
                    xpBarChild.style.backgroundColor = 'white';
                    xpBar.appendChild(xpBarChild);
                }
                if(gameData.xp > i){
                    xpBar.children[i].style.backgroundColor = 'black';
                }
            }
            if(gameData.xp >= gameData.xpToNextLevel){
                gameData.xp -= gameData.xpToNextLevel;
                gameData.xpToNextLevel *= 1.5;
                gameData.level++;
                for(let i = 0; i < xpBar.children.length; i++){
                    xpBar.children[i].style.backgroundColor = 'white';
                }
            }
        }, 1000/60);
    }

    function addXp(amnt){
        gameData.xp += amnt;
    }

    function spawnGrunt(i){
        const enemy = document.createElement('div');
        enemy.style.position = 'absolute';
        enemy.style.left = Math.random() * (area.getBoundingClientRect().width - 200) + 'px';
        enemy.style.top = Math.random() * (area.getBoundingClientRect().height - 200) + 'px';
        enemy.style.width = '20px';
        enemy.style.height = '20px';
        enemy.style.backgroundColor = 'black';
        enemy.style.zIndex = '1';
        enemy.id = `${enemies[i].name}-${i}`;
        enemy.setAttribute('collider', 'true');
        gameData.enemyCount++;
        area.appendChild(enemy);
    }
    function spawnSoldier(i){
        const enemy = document.createElement('div');
        enemy.style.position = 'absolute';
        enemy.style.left = Math.random() * (area.getBoundingClientRect().width - 200) + 'px';
        enemy.style.top = Math.random() * (area.getBoundingClientRect().height - 200) + 'px';
        enemy.style.width = '20px';
        enemy.style.height = '20px';
        enemy.style.backgroundColor = 'blue';
        enemy.style.zIndex = '1';
        enemy.id = `${enemies[i].name}-${i}`;
        enemy.setAttribute('collider', 'true');
        gameData.enemyCount++;
        area.appendChild(enemy);
    }

    function enemyController(){
        setInterval(function(){
            if(!gameData.playing) return;
            // excecute the lock functin in the enemy object when the current wave is equal to the wave the enemy is in
            for(let i = 0; i < Object.keys(enemies).length; i++){
                if(gameData.enemyCount == 0 && enemies[i].wave == gameData.currentWave){
                    if(!enemies[i].lock){
                        enemies[i].lock = true;
                        enemies[i].lockFunction(i);
                    }
                }
            }

        }, 1000/60);
    }

    // 300000

    screenSetup();
    gameoverController();
    updateXPBar();
    healthbarSetup();
    bulletController();
    playerController();
    enemyController();
    cannonController();
</script>