<style>
    html {
        font-family: monospace;
        user-select: none;
        font-size: 20px;
    }
    textarea::-webkit-scrollbar {
        display: none;
    }
    textarea {
        resize: none;
        font-family: monospace;
        outline: 0px;
        background-color: transparent;
        color: #CCCCCC;
    }

    .grid {
        border: 1px black solid;
        display: grid;
        grid-template-columns: repeat(22, 60px);
        grid-template-rows: repeat(4, 60px);
        width: calc(22 * 60px);
    }
    .container {
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px black solid;
    }
    .btn {
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: monospace;
        border: 1px black solid;
        border-radius: 2px;
        font-size: 15px;
        background-color: beige;
        width: 565px;
        height: 50px;
        font-size: 20px;
    }
    #syntax-highlighter {
        font-size: 10pt;
        padding-left: 3px;
        padding-top: 3px;
        color: black;
    }

</style>
<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://unpkg.com/custom-syntax-highlighter@latest/bin/index.js"></script>
</head>
<body>
    <a href="bs-docs.txt" download="bs-docs">
        <button position="absolute;">Download BadScript Docs</button>
    </a><br><br>
    <div id="grid" class="grid">

    </div>
    <span style="font-size: 19px">Input:</span>
    <div>
        <textarea cols="77" rows="6" maxlength="456" spellcheck="false" id="input" style="width: 565px; position: absolute; background-color: transparent; color: transparent; caret-color: black;"></textarea>
        <pre><code id="syntax-highlighter" style="font-family: monospace; position: absolute; width: 565px; height: 100px; z-index: -1;"></code></pre>
    </div>
    <br><br><br>&nbsp;<br><br>
    <span style="font-size: 19px">Output:<br></span>
    <textarea cols="77" rows="14" id="output" readonly style="width: 565px; color: black;"></textarea>
    <br>
    <br>
    <div class="btn" id="btn" onclick="run(input.value)">Run!</div>
</body>
<script>

const display = document.getElementById('grid');
const input = document.getElementById('input');
const output = document.getElementById('output');
const syntaxHighlighter = document.getElementById("syntax-highlighter")

let pointer = 1;

let memory = '';

let cellValues = [];
let outputArray = [];
let errorsArray = [];
let loops = []

const typesets = ["tD","tB", "tO", "tX","tU"]; // decimal, binary, octal, hexadecimal
const numberTypesets = [10,2,8,16]

let currentTypeset = "tD";

function checkTypeset(typeset){
    return typesets.includes(typeset)
}

function convertUni(unicode){
    if(unicode >= 0 && unicode <= 31 || unicode >= 127 && unicode <= 159){
        return unicode
    } else {
        return String.fromCharCode(unicode)
    }
}

const cellAmount = 88;
grid.style.setProperty('--cell-amount', cellAmount)

function validCell(cellNumber){
    return parseInt(cellNumber) >= 1 && parseInt(cellNumber) <= cellAmount;
}

function validCellValue(value){
    return value >= 0 && value <= 65536;
}

function repeat(value, times){
    let result = '';
    for(let i = 0; i < times; i++){
        result += value;
    }
    return result;
}

function loadCells(){
    for(let i = 1; i <= cellAmount; i++){
        let newValueCell = document.createElement('div');
        newValueCell.className = 'container';
        newValueCell.id = 'c' + i;
        if(i == 1){
            newValueCell.style.backgroundColor = 'beige'
        }
        newValueCell.innerHTML = '0';
        cellValues.push(0);
        display.appendChild(newValueCell);
    }
    pointer = 1;
}

function resetCells(){
    cellValues = [];
    outputArray = [];
    currentTypeset = "tD";
    loops = []
    for(let i = 1; i <= cellAmount; i++){
        cellValues.push(0);
        document.getElementById('c' + i).innerHTML = 0;
        document.getElementById("c" + i).style.backgroundColor = "beige";
        if(i != pointer){
            document.getElementById("c" + i).style.backgroundColor = "white";
        }
    }
    pointer = 1;
}

function updateCells(){

    for(let i = 1; i <= cellAmount; i++){
        let cellValue = cellValues[i - 1];
        if(currentTypeset == "tU"){
            document.getElementById('c' + i).innerHTML = convertUni(parseInt(cellValue))
        } else {
            document.getElementById('c' + i).innerHTML = String((cellValues[i - 1]).toString(numberTypesets[typesets.indexOf(currentTypeset)])).toUpperCase();
        }
        document.getElementById("c" + i).style.backgroundColor = "beige";
        if(i != pointer){
            document.getElementById("c" + i).style.backgroundColor = "white";
        }
    }
}

loadCells();

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
}

let running = false;

async function parse(instructions){
    if(running == false){
        running = true;
        for(i = -1; i < instructions.length; i++){
            let char = instructions[i];

            let comparisonValue = ''

            for(j = i + 1; j < instructions.length; j++){
                if(/\d/.test(instructions[j])){
                    comparisonValue += instructions[j]
                } else if(instructions[j] === "?"){
                    j = instructions.length
                }
            }
            if(char === ">"){
                if(cellValues[pointer - 1] == parseInt(comparisonValue) || comparisonValue == ''){
                    pointer++;
                    if(!validCell(pointer)){
                        pointer = cellAmount;
                        outputArray.push(`\nERROR: Pointer out of bounds. (char ${i+1})`);
                        outputArray.push(`\n${instructions}`)
                        outputArray.push(`\n${repeat(" ", i)}^`);
                        i = instructions.length;
                    }
                }
            }
            if(char === "<"){
                if(cellValues[pointer - 1] == parseInt(comparisonValue) || comparisonValue == ''){
                    pointer--;
                    if(!validCell(pointer)){
                        pointer = 1;
                        outputArray.push(`\nERROR: Pointer out of bounds. (char ${i+1})`);
                        outputArray.push(`\n${instructions}`)
                        outputArray.push(`\n${repeat(" ", i)}^`);
                        i = instructions.length;
                    }
                }
            }
            if(char === "+"){
                if(!validCellValue(cellValues[pointer - 1])){
                    outputArray.push(`\nERROR: Invalid cell value. (char ${i+1})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i)}^`);
                    i = instructions.length;
                } else {
                    cellValues[pointer - 1]++;
                }
            }
            if(char === "-"){
                if(!validCellValue(cellValues[pointer - 1])){
                    outputArray.push(`\nERROR: Invalid cell value. (char ${i+1})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i)}^`);
                    i = instructions.length;
                } else {
                    cellValues[pointer - 1]--;
                }
            }
            if(char === "."){
                if(currentTypeset == "tU"){
                    outputArray.push(convertUni(cellValues[pointer - 1]))
                } else {
                    outputArray.push((cellValues[pointer - 1]).toString(numberTypesets[typesets.indexOf(currentTypeset)]));
                }
            }
            if(char === "t"){
                let typeset = "t" + instructions[i + 1];
                if(!checkTypeset(typeset)){
                    outputArray.push(`\nERROR: Invalid typeset. (char ${i+2})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i + 1)}^`);
                    i = instructions.length;
                } else {
                    currentTypeset = typeset;
                    i++;
                }
            }
            if(char === "["){
                
                let matchingIndex = instructions.indexOf("]", i);
                if(matchingIndex == -1){
                    outputArray.push(`\nERROR: Matching closed bracket expected. (char ${i+1})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i + 1)}^`);
                    i = instructions.length;
                } else {
                    let temp_i = i;
                    let ignore = 0;

                    while(1) {
                        temp_i++;
                        if(!validCell(temp_i)){}else{
                            if(instructions[temp_i] === "[") {
                                ignore++ 
                            }
                            if(instructions[temp_i] === "]") {
                                if(ignore === 0) {
                                    if(cellValues[pointer - 1] === 0) {
                                        i = temp_i
                                    } else {
                                        loops[temp_i] = i
                                    }
                                    break;
                                } else ignore--;
                            }
                        }
                    }
                }
            }
            if(char === "]"){
                let matchingIndex = instructions.lastIndexOf("[", i);
                if(matchingIndex == -1){
                    outputArray.push(`\nERROR: Matching open bracket expected. (char ${i+1})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i + 1)}^`);
                    i = instructions.length;
                } else {
                    if(cellValues[pointer - 1] !== 0) {
                        i = loops[i]
                    } else {
                        loops[i]
                    };
                }
            }
            if(char === "?"){
                if(!/[0-9]/g.test(instructions[i-1])){
                    outputArray.push(`\nERROR: Unexpected comparison operator. (char ${i+1})`);
                    outputArray.push(`\n${instructions}`)
                    outputArray.push(`\n${repeat(" ", i + 1)}^`);
                    i = instructions.length;
                }
            }


            updateCells()
            output.value = outputArray.join("").trim();
            await this.timeout(10)
        }
    }
    running = false;
}

function run(struct){
    resetCells()
    parse(struct)
    updateCells()
}


$("textarea").keydown(function(e){
    // Enter pressed
    if (e.keyCode == 13)
    {
        //method to prevent from default behaviour
        e.preventDefault();
    }
});
</script>
<style>
    .value {
        color:#84ACFC;
    }
    .int {
        color:#EE96D7;
    }
    .loop {
        color: #F7A869;
    }
    .endchar {
        color: #AEBBCC;
    }
    .typeset {
        color: #33C89F;
    }
    .out {
        color: #84ACFC;
    }
    .shift {
        color: #d16969;
    }
    .error {
        color: #FF0000;
    }
    .other {
        color: #95C7C8;
    }
    .comparison {
        color: #fdcf78;;
    }


    .syntax-colors {
        color: #C3A6FE;
        color: #fdcf78;
        color: #e2bad6;
        color: #80CBC4;
        color: #FF839C;
    }
</style>
<script>

var highlight = window.csHighlight;

// 81, 486
let syntaxHighlighterArray;

setInterval(() => {

    syntaxHighlighter.innerText = input.value.replace(/.{76}/g, "$&" + "\n")



    highlight({
        patterns:
        [
            {
                name: "shift",
                match: /^(<|>)/
            },
            {
                name: "int",
                match: /^(\d)/
            },
            {
                name: "typeset",
                match: /^(t[DBXOU])/
            },
            {
                name: "loop",
                match: /^(\[|\])/
            },
            {
                name: "out",
                match: /^(\.)/
            },
            {
                name: "value",
                match: /^(\+|-)/
            },
            {
                name: "error",
                match: /^([^\d\+\-\[\]\;\:\.<>\?])/
            },
            {
                name: "error",
                match: /^([^t][DBXOU])/
            },
            {
                name: "comparison",
                match: /^(\?)/
            }
        ],
    })
}, 1)
    


</script>