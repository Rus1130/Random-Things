<style>
    html {
        font-family: monospace;
        user-select: none;
        font-size: 20px;
    }
    textarea::-webkit-scrollbar {
        display: none;
    }
    textarea {
        resize: none;
        font-family: monospace;
        outline: 0px;
        background-color: transparent;
    }

    .grid {
        border: 1px black solid;
        display: grid;
        grid-template-columns: repeat(22, 60px);
        grid-template-rows: repeat(4, 60px);
        width: calc(22 * 60px);
    }
    .container {
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px black solid;
    }
    .btn {
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: monospace;
        border: 1px black solid;
        border-radius: 2px;
        font-size: 15px;
        background-color: beige;
        width: 600px;
        height: 50px;
        font-size: 20px;
    }
    #syntax-highlighter {
        font-size: 10pt;
        padding-left: 3px;
        padding-top: 3px;
        color: black;
    }

</style>
<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>
    <div id="grid" class="grid">

    </div>
    <br>
    <span style="font-size: 19px">Input:<br></span>
    <div>
        <textarea cols="77" rows="6" maxlength="462" spellcheck="false" id="input" style="width: 600px; position: absolute; background-color: transparent; color: transparent; caret-color: black;"></textarea>
        <div id="syntax-highlighter" style="position: absolute; width: 600px; height: 100px; z-index: -1"></div>
    </div>
    <br><br><br>&nbsp;<br><br>
    <span style="font-size: 19px">Output:<br></span>
    <textarea cols="77" rows="17" id="output" readonly style="width: 600px"></textarea>
    <br>
    <br>
    <div class="btn" id="btn" onclick="run(input.value)">Run!</div>
</body>
<script>

const display = document.getElementById('grid');
const input = document.getElementById('input');
const output = document.getElementById('output');
const syntaxHighlighter = document.getElementById("syntax-highlighter")

let pointer = 1;

let memory = '';

let cellValues = [];
let outputArray = [];
let errorsArray = [];
let loops = []

const typesets = ["tD","tB", "tO", "tX"]; // decimal, binary, octal, hexadecimal
const numberTypesets = [10,2,8,16]

let currentTypeset = "tD";

function checkTypeset(typeset){
    return typesets.includes(typeset)
}

function changeToSaveUnicode(unicode){
    Boolean(unicode >= 0 && unicode <= 31 || unicode >= 127 && unicode <= 159)
}

const cellAmount = 88;
grid.style.setProperty('--cell-amount', cellAmount)

function validCell(cellNumber){
    return cellNumber >= 1 && cellNumber <= cellAmount;
}

function repeat(value, times){
    let result = '';
    for(let i = 0; i < times; i++){
        result += value;
    }
    return result;
}

function loadCells(){
    for(let i = 1; i <= cellAmount; i++){
        let newValueCell = document.createElement('div');
        newValueCell.className = 'container';
        newValueCell.id = 'c' + i;
        if(i == 1){
            newValueCell.style.backgroundColor = 'beige'
        }
        newValueCell.innerHTML = '0';
        cellValues.push(0);
        display.appendChild(newValueCell);
    }
    pointer = 1;
}

function resetCells(){
    cellValues = [];
    outputArray = [];
    loops = []
    for(let i = 1; i <= cellAmount; i++){
        cellValues.push(0);
        document.getElementById('c' + i).innerHTML = 0;
        document.getElementById("c" + i).style.backgroundColor = "beige";
        if(i != pointer){
            document.getElementById("c" + i).style.backgroundColor = "white";
        }
    }
    pointer = 1;
}

function updateCells(){
    errorsArray = []
    for(let i = 1; i <= cellAmount; i++){
        let cellValue = cellValues[i - 1];
        document.getElementById('c' + i).innerHTML = String((cellValues[i - 1]).toString(numberTypesets[typesets.indexOf(currentTypeset)])).toUpperCase();
        document.getElementById("c" + i).style.backgroundColor = "beige";
        if(i != pointer){
            document.getElementById("c" + i).style.backgroundColor = "white";
        }
    }
}

loadCells();

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
}

let running = false;

async function parse(instructions){
    if(running == false){
        running = true;
        for(i = -1; i < instructions.length; i++){
            let char = instructions[i]
            if(char === ">"){
                pointer++;
                if(!validCell(pointer)){
                    pointer = cellAmount;
                    outputArray.push(`ERROR: Pointer out of bounds. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                    i = instructions.length;
                }
            }
            if(char === "<"){
                pointer--;
                if(!validCell(pointer)){
                    pointer = 1;
                    outputArray.push(`ERROR: Pointer out of bounds. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                    i = instructions.length;
                }
            }
            if(char === "+"){
                cellValues[pointer - 1]++;
            }
            if(char === "-"){
                cellValues[pointer - 1]--;
            }
            if(char === "."){
                outputArray.push((cellValues[pointer - 1]).toString(numberTypesets[typesets.indexOf(currentTypeset)]));
            }
            if(char === "@"){
                memory = cellValues[pointer - 1] 
            }
            if(char === "_"){
                if(memory == ''){
                    outputArray.push(`ERROR: cannot set cell as empty. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                    i = instructions.length;
                } else {
                    cellValues[pointer - 1] = memory;
                }
            }
            if(char === "t"){
                let typeset = "t" + instructions[i + 1];
                if(!checkTypeset(typeset)){
                    outputArray.push(`ERROR: Invalid typeset. (char ${i+2})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i + 1) + "^");
                    i = instructions.length;
                } else {
                    currentTypeset = typeset;
                    i++;
                }
            }
            if(char === "&"){
                await this.timeout(100)
            }
            if(char === "["){
                // get index of matching ]
                let matchingIndex = instructions.indexOf("]", i);
                if(matchingIndex == -1){
                    outputArray.push(`ERROR: Matching closed bracket expected. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                } else {
                    let temp_i = i;
                    let ignore = 0;

                    while(1) {
                        temp_i++;
                        if(!validCell(temp_i)){}else{
                            if(instructions[temp_i] === "[") ignore++;
                            if(instructions[temp_i] === "]") {
                                if(ignore === 0) {
                                    if(cellValues[pointer - 1] === 0) {
                                        i = temp_i
                                    } else {
                                        loops[temp_i] = i
                                    }
                                    break;
                                } else ignore--;
                            }
                        }
                    }
                }
            }
            if(char === "]"){
                let matchingIndex = instructions.lastIndexOf("[", i);
                if(matchingIndex == -1){
                    outputArray.push(`ERROR: Matching open bracket expected. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                } else {
                    if(cellValues[pointer - 1] !== 0) {
                        i = loops[i]
                    } else {
                        loops[i]
                    };
                }
            }
            if(char === "{"){
                let matchingIndex = instructions.indexOf("'", i);
                if(matchingIndex == -1){
                    outputArray.push(`ERROR: Matching apostrophe expected. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                } else {
                    let cellJump = instructions.substring(i + 1, matchingIndex);
                    if(!validCell(cellJump)){
                        outputArray.push(`ERROR: Invalid cell jump. (char ${i+2})`);
                        outputArray.push(instructions)
                        outputArray.push(repeat(" ", i + 1) + "^");
                    } else {
                        if(cellValues[pointer - 1] === 0) {
                            pointer = cellJump;
                        }
                    }
                }
            }
            if(char === "}"){
                let matchingIndex = instructions.indexOf("'", i);
                if(matchingIndex == -1){
                    outputArray.push(`ERROR: Matching apostrophe expected. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                } else {
                    let cellJump = instructions.substring(i + 1, matchingIndex);
                    if(!validCell(cellJump)){
                        outputArray.push(`ERROR: Invalid cell jump. (char ${i+2})`);
                        outputArray.push(instructions)
                        outputArray.push(repeat(" ", i + 1) + "^");
                    } else {
                        if(cellValues[pointer - 1] !== 0) {
                            pointer = cellJump;
                        }
                    }
                }
            }
            if(char === "("){
                let matchingIndex = instructions.indexOf(")", i);
                // isolate the string between the parentheses
                let conditionStatement = instructions.substring(i + 1, matchingIndex).split("'");
                if(conditionStatement.length != 3){
                    outputArray.push(`ERROR: Missing arguments. (char ${i+1})`);
                    outputArray.push(instructions)
                    outputArray.push(repeat(" ", i) + "^");
                }
            }


            updateCells()
            output.value = outputArray.join("\n");;
            await this.timeout(300)
        }
    }
    running = false;
}

function run(struct){
    resetCells()
    parse(struct)
    updateCells()
}


$("textarea").keydown(function(e){
    // Enter pressed
    if (e.keyCode == 13)
    {
        //method to prevent from default behaviour
        e.preventDefault();
    }
});
</script>
<style>
    .pointer-shift {
        color:#84ACFC;
    }
    .integer {
        color:#EE96D7;
    }
    .loop {
        color: #F7A869;
    }
    .comment {
        color: #AEBBCC;
    }
    .endchar {
        color: #CCCCCC;
    }
    .typeset {
        color: #a4d676;
    }
    .parens {
        color: #ff839c;
    }
    .io {
        color: #C3A6FE;
    }
    .syntax-colors {
        color: #d16969;
    }
</style>
<script>

const highlightable_characters = [">","<","+","-","[","]","'","(",")","D","B","O","X","t",",","."]
// [".",",","@","_","&","{","}"]

const highlightable_digits = ["0","1","2","3","4","5","6","7","8","9"]

let charsToHighlight = [...input.value]
let highlighter = []

setInterval(() => {
    highlighter = []
    charsToHighlight = [...input.value]
    for(j = 0; j < charsToHighlight.length; j++){
        let char = charsToHighlight[j];
        if(char === ">" || char === "<" || char === "-" || char === "+"){
            highlighter.push(`<span class="pointer-shift">${char}</span>`)

        } else if (highlightable_digits.includes(char)){
            highlighter.push(`<span class="integer">${char}</span>`)

        } else if(char === "[" || char === "]"){
            highlighter.push(`<span class="loop">${char}</span>`)

        } else if(char === 't' && charsToHighlight[j + 1] == "D" || charsToHighlight[j + 1] == "B" || charsToHighlight[j + 1] == "O" || charsToHighlight[j + 1] == "X"){
            highlighter.push(`<span class="typeset">${char}</span>`)

        } else if(charsToHighlight[j - 1] == "t" && char == "D" || char == "B" || char == "O" || char == "X"){
            highlighter.push(`<span class="typeset">${char}</span>`)

        } else if(char === "'"){
            highlighter.push(`<span class="endchar">${char}</span>`)

        } else if(char === "(" || char === ')'){
            highlighter.push(`<span class="parens">${char}</span>`)

        } else if(char === "." || char === ","){
            highlighter.push(`<span class="io">${char}</span>`)

        }else {
            highlighter.push(`<span class="comment">${char}</span>`)
        }
    }

    syntaxHighlighter.innerHTML = highlighter.join("")

}, 1)
    


</script>