<style>
    html {
        font-family: monospace;
        user-select: none;
        font-size: 20px;
    }
    textarea {
        resize: none;
        font-family: monospace;
        outline: 0px;
    }
    .grid {
        border: 1px black solid;
        display: grid;
        grid-template-columns: repeat(var(--cell-amount), 60px);
        grid-template-rows: repeat(2, 60px);
        width: calc(var(--cell-amount) * 60px);
    }
    .container {
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px black solid;
    }
    .btn {
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: monospace;
        border: 1px black solid;
        border-radius: 2px;
        font-size: 15px;
        background-color: beige;
        width: 600px;
        height: 50px;
        font-size: 20px;
    }
</style>
<head>
</head>
<body>
    <div id="grid" class="grid">

    </div>
    <br>
    <span style="font-size: 19px">Input:<br></span>
    <textarea cols="77" rows="3" id="input"></textarea>
    <br>
    <br>
    <span style="font-size: 19px">Output:<br></span>
    <textarea cols="77" rows="25" id="output" readonly></textarea>
    <br>
    <br>
    <div class="btn" id="btn" onclick="run(input.value, false)">Run!</div>
</body>
<script>

const display = document.getElementById('grid');
const input = document.getElementById('input');
const output = document.getElementById('output');
let running = false;

let pointer = 1;
let pointerspeed = 1000

let memory = '';

let cellValues = [];
let outputArray = [];

const shebangs = ["#!D|","#!B|", "#!O|", "#!X|"]; // decimal, binary, octal, hexadecimal
const numberShebangs = [10,2,8,16]

let currentShebang = "#!D|";

function checkShebang(shebang){
    return shebangs.includes(shebang)
}

function checkUnicodeSafeCell(unicode){
    Boolean(unicode >= 0 && unicode <= 31 || unicode >= 127 && unicode <= 159)
}

const cellAmount = 22;
grid.style.setProperty('--cell-amount', cellAmount)

function validCell(cellNumber){
    return cellNumber >= 1 && cellNumber <= cellAmount;
}

function loadCells(){
    for(let i = 1; i <= cellAmount; i++){
        let newValueCell = document.createElement('div');
        newValueCell.className = 'container';
        newValueCell.id = 'c' + i;
        newValueCell.innerHTML = '0';
        cellValues.push(0);
        display.appendChild(newValueCell);
    }
    for(let i = 1; i <= cellAmount; i++){
        let newPoinerCell = document.createElement('div');
        newPoinerCell.className = 'container';
        newPoinerCell.id = 'p' + i;
        newPoinerCell.innerHTML = i == 1 ? '^' : ""
        display.appendChild(newPoinerCell);
    }
    pointer = 1;
}

function resetCells(){
    cellValues = [];
    outputArray = [];
    for(let i = 1; i <= cellAmount; i++){
        cellValues.push(0);
        document.getElementById('c' + i).innerHTML = 0;
        document.getElementById("p" + i).innerHTML = i == 1 ? '^' : "";
    }
    pointer = 1;
}

function updateCells(){
    for(let i = 1; i <= cellAmount; i++){
        let cellValue = cellValues[i - 1];
        document.getElementById('c' + i).innerHTML = (cellValues[i - 1]).toString(numberShebangs[shebangs.indexOf(currentShebang)]);
        document.getElementById("p" + i).innerHTML = i == pointer ? '^' : "";
    }
}

loadCells();

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
}

async function parse(instructions){
    for(i = -1; i < instructions.length; i++){
        let char = instructions[i]
        if(char === ">"){
            pointer++;
            if(!validCell(pointer)){
                pointer = cellAmount;
                outputArray.push(`ERROR: pointer cannot go out of bounds (char ${i+1})`);
                running = false;
            }
        } else if(char === "<"){
            pointer--;
            if(!validCell(pointer)){
                pointer = 1;
                outputArray.push(`ERROR: pointer cannot go out of bounds (char ${i+1})`);
                running = false;
            }
        } else if(char === "@"){
            pointerspeed = 50
        } else if(char === "_"){
            pointerspeed = 1000
        } else if(char === "+"){
            cellValues[pointer - 1]++;
        } else if(char === "-"){
            cellValues[pointer - 1]--;
        } else if(char === "."){
            outputArray.push((cellValues[pointer - 1]).toString(numberShebangs[shebangs.indexOf(currentShebang)]));
        } else if(char === "("){
            memory = cellValues[pointer - 1] 
        } else if(char === ")"){
            if(memory == ''){
                outputArray.push(`ERROR: cannot set an empty value (char ${i+1})`);
                running = false;
            } else {
                cellValues[pointer - 1] = memory;
            }
        } else if(char === "#"){
            shebang = instructions.substring(i, i + 4);
            if(!checkShebang(shebang)){
                outputArray.push(`ERROR: invalid shebang (char ${i+1})`);
                running = false;
            } else {
                currentShebang = shebang;
                i += 3;
            }
        } else if(char === "&"){
            await this.timeout(100)
        } else if(char === "["){ // jump if 0
            let matchingBracket = instructions.substring(i, instructions.length).indexOf(']') + i;
            if(matchingBracket == -1){
                outputArray.push(`ERROR: no matching bracket (char ${i+1})`);
                running = false;
            } else {
                let jumpCell = instructions.substring(i + 1, matchingBracket);
                let cellValue = cellValues[pointer - 1];
                if(cellValue == 0){
                    pointer = jumpCell;
                }
            }

        } else if(char === "]"){ // jump if not 0
            let matchingBracket = instructions.substring(i, instructions.length).indexOf('[') + i;
            if(matchingBracket == -1){
                outputArray.push(`ERROR: no matching reverse bracket (char ${i+1})`);
                running = false;
            } else {
                let jumpCell = instructions.substring(i + 1, matchingBracket);
                let cellValue = cellValues[pointer - 1];
                if(cellValue != 0){
                    pointer = jumpCell;
                }
            }
            
        } else if(char === "{"){ // jump if % 2 = 0
            let matchingBracket = instructions.substring(i, instructions.length).indexOf('}') + i;
            if(matchingBracket == -1){
                outputArray.push(`ERROR: no matching bracket (char ${i+1})`);
                running = false;
            } else {
                let jumpCell = instructions.substring(i + 1, matchingBracket);
                let cellValue = cellValues[pointer - 1];
                if(cellValue % 2 == 0){
                    pointer = jumpCell;
                }
            }

        } else if(char === "}"){ // jump if not 0
            let matchingBracket = instructions.substring(i, instructions.length).indexOf('{') + i;
            if(matchingBracket == -1){
                outputArray.push(`ERROR: no matching reverse bracket (char ${i+1})`);
                running = false;
            } else {
                let jumpCell = instructions.substring(i + 1, matchingBracket);
                let cellValue = cellValues[pointer - 1];
                if(cellValue % 2 != 0){
                    pointer = jumpCell;
                }
            }
        } else {}
        updateCells()
        output.value = outputArray.join("\n")
        await this.timeout(pointerspeed)
    }
}

function run(struct, returnMode){
    running = true;
    if(returnMode == false){
        resetCells()
    }
    parse(struct)
    updateCells()

    running = false;
}
</script>