<style>
    html {
        font-family: monospace;
    }
    textarea {
        resize: none;
    }
    textarea:focus {
        outline: none;
    }
</style>
<head>
    <script src="https://unpkg.com/hotkeys-js/dist/hotkeys.min.js"></script>
</head>
<body>
    <a href="docs.txt" download="Rustype-docs">
        <button position="absolute;">Download Docs</button>
    </a><br><br>
    <textarea id="input" rows="30" cols="80" autocomplete="off" spellcheck="false" title="code editor"></textarea>
    <textarea id="console" rows="30" cols="80" readonly spellcheck="false" title="code output"></textarea>
</body>
<script>

const input = document.getElementById("input")
const appConsole = document.getElementById("console")
let inputCodeArray;
let inputCodeLine;
let consoleArray = []
let codeStateArray = []
input.value = ""

hotkeys('enter', () => {
    compile(input.value, true)
})

let callstack = [] // touchable
let heap = [] // untouchable
const reserved_keywords = ["assign", "log", "pull", "push", "drop", "owrite", "eval", "show", "listener"]
const allowed_keys = /[a-zA-Z0-9space]/




function math(operation, num1, num2){
    switch(operation){
        case "add": //add
            return parseFloat((parseFloat(num1) + parseFloat(num2)).toPrecision(12));
            break
        case "sub": //subtract
            return parseFloat((parseFloat(num1) - parseFloat(num2)).toPrecision(12));
            break;
        case "mult": //multiply
            return parseFloat((parseFloat(num1) * parseFloat(num2)).toPrecision(12));
            break;
        case "div": //divide
            return parseFloat((parseFloat(num1) / parseFloat(num2)).toPrecision(12));
            break;
        case "mod": //modulus
            return parseFloat((parseFloat(num1) % parseFloat(num2)).toPrecision(12));
            break;
        default:
            return false;
            break;
    }
}

function compile(inputCode, resetValues){
    if(resetValues == true){
        heap = [];
        callstack = [];
        appConsole.innerHTML = "";
        codeStateArray = [];
        consoleArray = [];
    }
    try {
        inputCodeArray = inputCode.split("\n")
    }
    catch(e){}
    for(let i = 0; i < inputCodeArray.length; i++){
        inputCodeLine = inputCodeArray[i].split(" ")
        if(!reserved_keywords.includes(inputCodeLine[0])){
            consoleArray.push(`Error: Keyword error at line ${i+1}. ("${inputCodeLine[0]}" is an unknown keyword)`)
            codeStateArray.push(`compile error: unknown keyword`)
        } else {
            if(inputCodeLine[0] == reserved_keywords[0]){
                codeStateArray.push(`attempting to create variable`)
                if(!inputCodeLine[2].includes("to")){
                    consoleArray.push(`Error: Syntax error at line ${i+1}. (missing assignment operator)`)
                    codeStateArray.push("variable syntax error: missing assignment operator")
                } else {
                    if(heap.find(x => x.name == inputCodeLine[1])){
                        consoleArray.push(`Error: Variable creation error at line ${i+1}. ("${inputCodeLine[1]}" already exists)`)
                        codeStateArray.push(`variable exit error: variable already exists`)
                    } else {
                        let valueToSet = inputCodeArray[0].toString().split("to ")[1]
                        heap.push({name: inputCodeLine[1], value: valueToSet})
                        codeStateArray.push(`variable exit success: created variable with name of "${inputCodeLine[1]}" and value of ${inputCodeLine[2]}`)
                    }
                }
            }
            if(inputCodeLine[0] == reserved_keywords[1]){
                codeStateArray.push(`attempting to log the variable ${inputCodeLine[1]}`)
                if(callstack[callstack.findIndex(x => x.name == inputCodeLine[1])] == undefined){
                    consoleArray.push(`Error: Variable search error at line ${i+1}. ("${inputCodeLine[1]}" does not exist in callstack)`)
                    codeStateArray.push(`log exit error: variable search error: variable "${inputCodeLine[1]}" does not exist in callstack`)
                } else {
                    consoleArray.push(callstack[callstack.findIndex(x => x.name == inputCodeLine[1])].value)
                    codeStateArray.push(`log exit success: logged the value of "${inputCodeLine[1]}"`)
                }
            }
            if(inputCodeLine[0] == reserved_keywords[2]){
                codeStateArray.push(`attempting to pull the variable ${inputCodeLine[1]}`)
                if(heap.find(x => x.name == inputCodeLine[1])){
                    callstack.push({name: inputCodeLine[1], value: heap[heap.findIndex(x => x.name == inputCodeLine[1])].value})
                    heap.splice(heap.findIndex(x => x.name == inputCodeLine[1]), 1)
                    codeStateArray.push(`pull exit success: pulled the variable "${inputCodeLine[1]}" from heap to callstack`)
                } else {
                    consoleArray.push(`Error: Variable search error at line ${i+1}. ("${inputCodeLine[1]}" does not exist in heap)`)
                    codeStateArray.push(`pull exit error: variable search error: variable "${inputCodeLine[1]}" does not exist in heap`)
                }
            }
            if(inputCodeLine[0] == reserved_keywords[3]){
                codeStateArray.push(`attempting to push the variable ${inputCodeLine[1]}`)
                if(callstack.find(x => x.name == inputCodeLine[1])){
                    heap.push({name: inputCodeLine[1], value: callstack[callstack.findIndex(x => x.name == inputCodeLine[1])].value})
                    callstack.splice(callstack.findIndex(x => x.name == inputCodeLine[1]), 1)
                    codeStateArray.push(`push exit success: pushed the variable "${inputCodeLine[1]}" from callstack to heap`)
                } else {
                    consoleArray.push(`Error: Variable search error at line ${i+1}. ("${inputCodeLine[1]}" does not exist in callstack)`)
                    codeStateArray.push(`push exit error: variable search error: variable "${inputCodeLine[1]}" does not exist in callstack`)
                }
            }
            if(inputCodeLine[0] == reserved_keywords[4]){
                codeStateArray.push(`attempting to drop the variable ${inputCodeLine[1]}`)
                if(callstack.find(x => x.name == inputCodeLine[1])){
                    callstack.splice(callstack.findIndex(x => x.name == inputCodeLine[1]), 1)
                    codeStateArray.push(`drop exit success: dropped the variable "${inputCodeLine[1]}"`)
                } else {
                    consoleArray.push(`Error: Variable drop error at line ${i+1}. ("${inputCodeLine[1]}" does not exist)`)
                    codeStateArray.push(`drop exit error: variable "${inputCodeLine[1]}" does not exist`)
                }
            }
            if(inputCodeLine[0] == reserved_keywords[5]){
                codeStateArray.push(`attempting to overwrite the variable ${inputCodeLine[1]}`)
                if(!inputCodeLine[2].includes("to")){
                    consoleArray.push(`Error: Syntax error at line ${i+1}. (missing assignment operator)`)
                    codeStateArray.push(`overwrite exit error: missing assignment operator`)
                } else {
                    if(callstack.find(x => x.name == inputCodeLine[1])){
                        let newValue = inputCodeLine.join(" ").split("to ")[1]
                        callstack[callstack.findIndex(x => x.name == inputCodeLine[1])].value = newValue
                        codeStateArray.push(`owrite exit success: overwrote the value of "${inputCodeLine[1]}"`)
                    } else {
                        consoleArray.push(`Error: Variable overwrite error at line ${i+1}. ("${inputCodeLine[1]}" does not exist)`)
                        codeStateArray.push(`owrite exit error: variable "${inputCodeLine[1]}" does not exist`)
                    }
                }
            }
            if(inputCodeLine[0] == reserved_keywords[6]){
                codeStateArray.push(`attempting to evaluate expression`)
                if(inputCodeLine[1] == undefined || inputCodeLine[2] == undefined || inputCodeLine[3] == undefined){
                    consoleArray.push(`Error: Syntax error at line ${i+1}. (missing evaluation arguments)`)
                    codeStateArray.push(`evaluation exit error: missing evaluation arguments`)
                } else {
                    let number1 = inputCodeLine[1]
                    let operation = inputCodeLine[2]
                    let number2 = inputCodeLine[3]
                    if(math(operation, number1, number2) == false){
                        consoleArray.push(`Error: Evaluation error at line ${i+1}. (invalid evaluation operation)`)
                        codeStateArray.push(`evaluation exit error: invalid evaluation operation`)
                    } else {
                        consoleArray.push(math(operation, number1, number2))
                        codeStateArray.push(`evaluation exit success: evaluated expression`)
                    }
                }
            }
            if(inputCodeLine[0] == reserved_keywords[7]){
                switch(inputCodeLine[1]){
                    case "heap":
                        consoleArray.push("Variables in Heap:\n"+JSON.stringify(heap))
                        break;
                    case "callstack":
                    consoleArray.push("Variables in Heap:\n"+JSON.stringify(callstack))
                        break;
                    default:
                        consoleArray.push(`Error: Invalid argument at line ${i+1}. ("${inputCodeLine[0]}" is not a valid argument)`)
                        codeStateArray.push(`invalid argument error: "${inputCodeLine[0]}" is not a valid argument`)
                }
            }
            if(inputCodeLine[0] == reserved_keywords[8]){
                codeStateArray.push(`attempting to edit listeners`)
                if(!inputCodeLine.includes("=>") && inputCodeLine[1] != "remove"){
                    consoleArray.push(`Error: Syntax error at line ${i+1}. (missing assignment operator)`)
                    codeStateArray.push(`listener modification exit error: missing assignment operator`)
                } else {
                    if(!allowed_keys.test(inputCodeLine[2])){
                        consoleArray.push(`Error: System error at line ${i+1}. (assignment to reserved or invalid key)`)
                        codeStateArray.push(`listener modification exit error: assignment to reserved or invalid key`)
                    } else {
                        switch(inputCodeLine[1]){
                            case "add":
                                hotkeys(`${inputCodeLine[2]}`, () => {
                                    // create an array than joins the rest of the line until ;, then new array

                                    let codeToRun = inputCodeLine.join(" ").split("=> ")[1].split("; ")
                                    for(k = 0; k < codeToRun.length; k++){
                                        compile(codeToRun[k], false)
                                    }
                                })
                                break;
                            case "remove":
                                    hotkeys.unbind(`${inputCodeLine[2]}`)
                                break;
                            default:
                                consoleArray.push(`Error: Listener handling error at line ${i+1}. (missing handler)`)
                                codeStateArray.push(`listener modification exit error: missing handler`)
                                break;
                            }
                    }
                }
            }
        }
    }

    appConsole.innerHTML = consoleArray.join("\n")
}

</script>