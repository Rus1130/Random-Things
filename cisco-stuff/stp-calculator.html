<style>
    .button {
        outline: 1px black solid;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        height: 50px;
        width: 130px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    .diagram {
        position: absolute;
        right: 20px;
        top: 20px;
        width: 600px;
        height: 600px;
        outline: 1px solid black;
    }
    .point {
        height: 10px;
        width: 10px;
        border-radius: 100%;
        position: fixed;
        background-color: black;
    }
    .draggable {
        cursor: move;
        position: absolute;
        user-select: none;
    }
</style>
<head>

</head>
<body>

    <div id="rootBridgeDisplay" style="width:max-content"></div><br>
    <div id="portsDisplay" style="width:max-content"></div>

    <br>
    <div class="button" onclick="calculate()">Calculate STP</div>
    <div id="diagram" class="diagram" style="background-color: transparent; z-index: 20;"></div>
    <div id="lineDrawer" class="diagram"></div>
</body>
<script>
    const rootBridgeDisplay = document.getElementById('rootBridgeDisplay');
    const portsDisplay = document.getElementById('portsDisplay');
    const diagram = document.getElementById('diagram');
    const lineDrawer = document.getElementById('lineDrawer');

    let devices = {};

    // get the device with the lowest priority, if all priorities are the same, get the device with the lowest MAC address
    function getRootDevice() {
        let rootDevice = null;
        let rootPriority = 65535;
        let rootMAC = 'FFFF.FFFF.FFFF';

        for (let device in devices) {
            if (devices[device].priority < rootPriority) {
                rootDevice = device;
                rootPriority = devices[device].priority;
                rootMAC = devices[device].MACaddress;
            } else if (devices[device].priority == rootPriority) {
                if (devices[device].MACaddress < rootMAC) {
                    rootDevice = device;
                    rootPriority = devices[device].priority;
                    rootMAC = devices[device].MACaddress;
                }
            }
        }

        return rootDevice;
    }
    
    function generatePortModel(thisDevice, thisPort, connectedDevice, connectedPort) {

        return {[thisPort] : {
            thisDevice: thisDevice,
            thisPort: thisPort,
            thisPortType: null,

            connectedDevice: connectedDevice,
            connectedPort: connectedPort,
        }};
    }


    function addDevice(device, priority, MACaddress, ports) {
        devices[device] = {
            priority: priority,
            rootBridge: false,
            MACaddress: MACaddress,
            ports: ports.reduce((acc, port) => {
                return {...acc, ...port};
            }, {})
        }
    }

    function generateDeviceModel(){
        addDevice('SW1', 32769, '014A.38F1.BA81', [
            generatePortModel("SW1", "g0/0", 'SW2', "g0/2"), 
            generatePortModel("SW1", "g0/1", "SW3", "g0/0"),
            generatePortModel("SW1", "g0/2", "SW2", "g0/1"),
        ]);
        addDevice('SW2', 32769, '193D.72DE.36E1', [
            generatePortModel("SW2", "g0/0", 'SW4', "g0/1"), 
            generatePortModel("SW2", "g0/1", "SW1", "g0/2"),
            generatePortModel("SW2", "g0/2", "SW1", "g0/0"),
        ]);
        addDevice('SW3', 32769, '014A.3821.2981', [
            generatePortModel("SW3", "g0/0", 'SW1', "g0/1"), 
            generatePortModel("SW3", "g0/1", "SW4", "g0/0"),
        ]);
        addDevice('SW4', 32769, '83F1.2846.392F', [
            generatePortModel("SW4", "g0/0", 'SW3', "g0/1"), 
            generatePortModel("SW4", "g0/1", "SW2", "g0/0")
        ]);	
    }

    function calculate(){
        generateDeviceModel()
        let rootBridge = getRootDevice();
        devices[rootBridge].rootBridge = true;

        let rootPorts = {}

        for (let device in devices) {
            if(devices[device].rootBridge) continue;
            let rootPort = null;
            let rootPriority = 65535;
            let rootMAC = 'FFFF.FFFF.FFFF';
            let rootPortID = 255;

            // calculate the root port for each device using the lowest root cost AND lowest neighbor priority (Both neighbors) AND lowest neighbor port id (both neighbors)
            for (let port in devices[device].ports) {
                let connectedDevice = devices[device].ports[port].connectedDevice;
                let connectedPort = devices[device].ports[port].connectedPort;
                let connectedPortID = devices[device].ports[port].connectedPort.slice(-1);
                let connectedPriority = devices[connectedDevice].priority;
                let connectedMAC = devices[connectedDevice].MACaddress;

                if (connectedPriority < rootPriority) {
                    rootPort = port;
                    rootPriority = connectedPriority;
                    rootMAC = connectedMAC;
                } else if (connectedPriority == rootPriority) {
                    if (connectedMAC < rootMAC) {
                        rootPort = port;
                        rootPriority = connectedPriority;
                        rootMAC = connectedMAC;
                    } else if (connectedMAC == rootMAC) {
                        if (connectedPortID < rootPortID) {
                            rootPort = port;
                            rootPriority = connectedPriority;
                            rootMAC = connectedMAC;
                        }
                    }
                }
                
            }

            let connectedDevice = devices[device].ports[rootPort].connectedDevice;
            let connectedPort = devices[device].ports[rootPort].connectedPort;

            devices[connectedDevice].ports[connectedPort].thisPortType = 'designated';
            devices[device].ports[rootPort].thisPortType = 'root';
            rootPorts[device] = rootPort;

        }


        let ports = ``;
        for(i = 0; i < Object.keys(devices).length; i++){
            let devicesArray = Object.keys(devices);
            for(j = 0; j < Object.keys(devices[devicesArray[i]].ports).length; j++){
                let portsArray = Object.keys(devices[devicesArray[i]].ports);
                ports += `<div>Port ${portsArray[j]} on ${devicesArray[i]} should be a ${devices[devicesArray[i]].ports[portsArray[j]].thisPortType} port. (dest: ${devices[devicesArray[i]].ports[portsArray[j]].connectedDevice} port ${devices[devicesArray[i]].ports[portsArray[j]].connectedPort})</div>`
                if(j == Object.keys(devices[devicesArray[i]].ports).length - 1){
                    ports += `<br>`
                }
            }
            
        }
        rootBridgeDisplay.innerHTML = `The root bridge is ${rootBridge}.`;
        portsDisplay.innerHTML = ports

        distributeDiagramDevices(Object.keys(devices).length, Object.keys(devices));

        console.log(devices)
        devices = {};
    }

    function distributeDiagramDevices(n, labels) {
        for(i = 0; i < n; i++){
            let deviceDiv = document.createElement('div');
            deviceDiv.classList.add('draggable');
            deviceDiv.id = labels[i];
            deviceDiv.style.height = '50px';
            deviceDiv.style.width = '50px';
            deviceDiv.style.border = '2px solid black';
            deviceDiv.style.top = '300px';
            deviceDiv.style.left = '300px';
            deviceDiv.style.borderRadius = '100%';
            deviceDiv.style.display = 'flex';
            deviceDiv.style.justifyContent = 'center';
            deviceDiv.style.alignItems = 'center';

            
            deviceDiv.innerHTML = labels[i];
            diagram.appendChild(deviceDiv);
            dragElement(document.getElementById(labels[i]));

            // draw lines between all of the devices
        }
    }

    // make a function that makes each device with the 'draggable' class that is a child of the diagram div draggable, make it so that the device can only be dragged within the diagram div
    function dragElement(elmnt) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        if (document.getElementById(elmnt.id + "header")) {
            // if present, the header is where you move the DIV from:
            document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
        } else {
            // otherwise, move the DIV from anywhere inside the DIV:
            elmnt.onmousedown = dragMouseDown;
        }

        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;

            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            if(elmnt.offsetTop - pos2 <= 0){
                elmnt.style.top = '0px';
            }
            if(elmnt.offsetTop - pos2 >= 546){
                elmnt.style.top = '546px';
            }
            if(elmnt.offsetLeft - pos1 <= 0){
                elmnt.style.left = '0px';
            }
            if(elmnt.offsetLeft - pos1 >= 546){
                elmnt.style.left = '546px';
            }
            // set the element's new position:
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";

            let deviceArray = document.getElementsByClassName('draggable');
            for(i = 0; i < deviceArray.length; i++){
                for(j = 0; j < deviceArray.length; j++){
                    if(i != j){
                        lineDrawer.innerHTML = ''
                        let device1 = deviceArray[i];
                        let device2 = deviceArray[j];

                        

                       // lineDrawer.appendChild(line);
                    }
                }
            }
            
        }

        function closeDragElement() {
            // stop moving when mouse button is released:
            document.onmouseup = null;
            document.onmousemove = null;
        }
        
    }



    // file:///C:/Users/aarogozin2026/Downloads/STP_Spanning_Tree_Protocol.pdf
    // https://techhub.hpe.com/eginfolib/networking/docs/switches/7500/5200-1938a_l2-lan_cg/content/495503520.htm

</script>