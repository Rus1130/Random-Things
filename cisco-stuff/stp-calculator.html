<style>
    .button {
        outline: 1px black solid;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        height: 50px;
        width: 130px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    .diagram {
        position: absolute;
        right: 20px;
        top: 20px;
        width: 600px;
        height: 600px;
        outline: 1px solid black;
    }
    .draggable {
        cursor: move;
        position: absolute;
        user-select: none;
    }
    svg {
        overflow: visible;
    }
    textarea {
        resize: none;
    }
    textarea:focus {
        outline: none;
    }
    .color-display {
        width: 20px;
        height: 20px;
        border-radius: 100%;
        font-family: monospace;
        font-size: 18px;
        /* remove auto line break*/
        white-space: nowrap;
    }
    #code-input {
        border-radius: 0%;
        position: absolute;
        right: 20px;
        top: 625px;
        width: 601px;
        height: 150px;
        font-family: monospace;
        font-size: 18px;
        resize: none;
    }
</style>
<head>

</head>
<body>

    <div id="rootBridgeDisplay" style="width:max-content"></div><br>
    <div id="portsDisplay" style="width:max-content"></div>

    <br>
    <div class="button" onclick="calculate()">Calculate STP</div>
    <div id="diagram" class="diagram" style="background-color: transparent; z-index: 20;"></div>
    <div id="lineDrawer" class="diagram" style="z-index: -20"></div>
    <br>
    <div class="color-display" style="background-color: gold">&nbsp;&nbsp;&nbsp;Root&nbsp;Port</div><br>
    <div class="color-display" style="background-color: cornflowerblue">&nbsp;&nbsp;&nbsp;Designated&nbsp;Port</div><br>
    <div class="color-display" style="background-color: red">&nbsp;&nbsp;&nbsp;Non-Designated&nbsp;Port</div><br>
    <textarea id="code-input"></textarea>
</body>
<script>
    const rootBridgeDisplay = document.getElementById('rootBridgeDisplay');
    const portsDisplay = document.getElementById('portsDisplay');
    const diagram = document.getElementById('diagram');
    const lineDrawer = document.getElementById('lineDrawer');

    let devices = {};

    // get the device with the lowest priority, if all priorities are the same, get the device with the lowest MAC address
    function getRootDevice() {
        let rootDevice = null;
        let rootPriority = 65535;
        let rootMAC = 'FFFF.FFFF.FFFF';

        for (let device in devices) {
            if (devices[device].priority < rootPriority) {
                rootDevice = device;
                rootPriority = devices[device].priority;
                rootMAC = devices[device].MACaddress;
            } else if (devices[device].priority == rootPriority) {
                if (devices[device].MACaddress < rootMAC) {
                    rootDevice = device;
                    rootPriority = devices[device].priority;
                    rootMAC = devices[device].MACaddress;
                }
            }
        }

        return rootDevice;
    }
    
    function generatePortModel(thisDevice, thisPort, connectedDevice, connectedPort) {

        return {[thisPort] : {
            thisDevice: thisDevice,
            thisPort: thisPort,
            thisPortType: null,

            connectedDevice: connectedDevice,
            connectedPort: connectedPort,
        }};
    }


    function addDevice(device, priority, MACaddress, ports) {
        devices[device] = {
            priority: priority,
            rootBridge: false,
            MACaddress: MACaddress,
            ports: ports.reduce((acc, port) => {
                return {...acc, ...port};
            }, {})
        }
    }


    function generateDeviceModel(){
        
        addDevice('SW1', 32769, '014A.38F1.BA81', [
            generatePortModel("SW1", "g0/0", 'SW2', "g0/2"), 
            generatePortModel("SW1", "g0/1", "SW3", "g0/0"),
            generatePortModel("SW1", "g0/2", "SW2", "g0/1"),
        ]);
        addDevice('SW2', 32769, '193D.72DE.36E1', [
            generatePortModel("SW2", "g0/0", 'SW4', "g0/1"), 
            generatePortModel("SW2", "g0/1", "SW1", "g0/2"),
            generatePortModel("SW2", "g0/2", "SW1", "g0/0"),
        ]);
        addDevice('SW3', 32769, '014A.3821.2981', [
            generatePortModel("SW3", "g0/0", 'SW1', "g0/1"), 
            generatePortModel("SW3", "g0/1", "SW4", "g0/0"),
        ]);
        addDevice('SW4', 32769, '83F1.2846.392F', [
            generatePortModel("SW4", "g0/0", 'SW3', "g0/1"), 
            generatePortModel("SW4", "g0/1", "SW2", "g0/0")
        ]);	
        
        
    }

    let rootPorts = {}

    function calculate(){
        devices = {};
        diagram.innerHTML = '';
        lineDrawer.innerHTML = '';
        generateDeviceModel()
        let rootBridge = getRootDevice();
        devices[rootBridge].rootBridge = true;

        rootPorts = {}

        for (let device in devices) {
            if(devices[device].rootBridge) continue;
            let rootPort = null;
            let rootPriority = 65535;
            let rootMAC = 'FFFF.FFFF.FFFF';
            let rootPortID = 255;

            // calculate the root port for each device using the lowest root cost AND lowest neighbor priority (Both neighbors) AND lowest neighbor port id (both neighbors)
            for (let port in devices[device].ports) {
                let connectedDevice = devices[device].ports[port].connectedDevice;
                let connectedPort = devices[device].ports[port].connectedPort;
                let connectedPortID = devices[device].ports[port].connectedPort.slice(-1);
                let connectedPriority = devices[connectedDevice].priority;
                let connectedMAC = devices[connectedDevice].MACaddress;

                if (connectedPriority < rootPriority) {
                    rootPort = port;
                    rootPriority = connectedPriority;
                    rootMAC = connectedMAC;
                } else if (connectedPriority == rootPriority) {
                    if (connectedMAC < rootMAC) {
                        rootPort = port;
                        rootPriority = connectedPriority;
                        rootMAC = connectedMAC;
                    } else if (connectedMAC == rootMAC) {
                        if (connectedPortID < rootPortID) {
                            rootPort = port;
                            rootPriority = connectedPriority;
                            rootMAC = connectedMAC;
                        }
                    }
                }
                
            }

            let connectedDevice = devices[device].ports[rootPort].connectedDevice;
            let connectedPort = devices[device].ports[rootPort].connectedPort;

            devices[connectedDevice].ports[connectedPort].thisPortType = 'designated';
            devices[device].ports[rootPort].thisPortType = 'root';
            rootPorts[device] = rootPort;

        }
        // out of all the ports with the type of 'null', on each device find the lowest port cost and set it to 'designated'
        for (let device in devices) {
            let lowestPortCost = 65535;
            let lowestPort = null;
            for (let port in devices[device].ports) {
                if(devices[device].ports[port].thisPortType == 'designated') continue;
                if(devices[device].ports[port].thisPortType == 'root') continue;
                let connectedDevice = devices[device].ports[port].connectedDevice;
                let connectedPort = devices[device].ports[port].connectedPort;
                let connectedPortID = devices[device].ports[port].connectedPort.slice(-1);
                let connectedPriority = devices[connectedDevice].priority;
                let connectedMAC = devices[connectedDevice].MACaddress;
                let connectedPortCost = devices[connectedDevice].ports[connectedPort].thisPortType == 'designated' ? 20000 : 10000;
                if (connectedPortCost < lowestPortCost) {
                    lowestPort = port;
                    lowestPortCost = connectedPortCost;
                }
            }
            if(lowestPort) {
                devices[device].ports[lowestPort].thisPortType = 'designated';
                // get the connected device and port and set it to non-designated
                let connectedDevice = devices[device].ports[lowestPort].connectedDevice;
                let connectedPort = devices[device].ports[lowestPort].connectedPort;
                devices[connectedDevice].ports[connectedPort].thisPortType = 'non-designated';
            }
        }

        let ports = ``;
        for(i = 0; i < Object.keys(devices).length; i++){
            let devicesArray = Object.keys(devices);
            for(j = 0; j < Object.keys(devices[devicesArray[i]].ports).length; j++){
                let portsArray = Object.keys(devices[devicesArray[i]].ports);
                ports += `<div>Port ${portsArray[j]} on ${devicesArray[i]} should be a ${devices[devicesArray[i]].ports[portsArray[j]].thisPortType} port. (dest: ${devices[devicesArray[i]].ports[portsArray[j]].connectedDevice} port ${devices[devicesArray[i]].ports[portsArray[j]].connectedPort})</div>`
                if(j == Object.keys(devices[devicesArray[i]].ports).length - 1){
                    ports += `<br>`
                }
            }
            
        }
        rootBridgeDisplay.innerHTML = `The root bridge is ${rootBridge}.`;
        portsDisplay.innerHTML = ports

        distributeDiagramDevices(Object.keys(devices).length, Object.keys(devices));
        
    }

    function distributeDiagramDevices(n, labels) {
        for(i = 0; i < n; i++){
            let deviceDiv = document.createElement('div');
            deviceDiv.classList.add('draggable');
            deviceDiv.id = labels[i];
            deviceDiv.style.height = '50px';
            deviceDiv.style.width = '50px';
            // check if it is the root device
            deviceDiv.style.border = '3px solid black';
            if(devices[labels[i]].rootBridge){
                deviceDiv.style.border = '3px solid gold';
            }
            deviceDiv.style.borderRadius = '10%';
            deviceDiv.style.display = 'flex';
            deviceDiv.style.justifyContent = 'center';
            deviceDiv.style.alignItems = 'center';
            deviceDiv.style.fontFamily = 'Monospace';

            deviceDiv.style.backgroundColor = 'white'
            deviceDiv.style.fontSize = '20px';

            // deviceDiv.style.backgroundColor = 'transparent'
            // deviceDiv.style.fontSize = '10px';
            

            // place the device so they are evenly distributed in a circle, with the first device in the top right
            let x = 200 * -Math.cos(2 * Math.PI * i / n) + 250;
            let y = 200 * Math.sin(2 * Math.PI * i / n) + 250;
            deviceDiv.style.left = x + 'px';
            deviceDiv.style.top = y + 'px';

            deviceDiv.innerHTML = labels[i];
            diagram.appendChild(deviceDiv);
            dragElement(document.getElementById(labels[i]));
            
        }
        drawConnections()
    }

    // make a function that makes each device with the 'draggable' class that is a child of the diagram div draggable, make it so that the device can only be dragged within the diagram div
    function dragElement(elmnt) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        elmnt.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;

            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            if(elmnt.offsetTop - pos2 <= 0){
                elmnt.style.top = '0px';
            }
            if(elmnt.offsetTop - pos2 >= 546){
                elmnt.style.top = '546px';
            }
            if(elmnt.offsetLeft - pos1 <= 0){
                elmnt.style.left = '0px';
            }
            if(elmnt.offsetLeft - pos1 >= 546){
                elmnt.style.left = '546px';
            }
            // set the element's new position:
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";

            drawConnections()  
        }

        function closeDragElement() {
            // stop moving when mouse button is released:
            document.onmouseup = null;
            document.onmousemove = null;
        }
        
    }

    function drawConnections(){
        lineDrawer.innerHTML = '';
        let deviceArray = document.getElementsByClassName('draggable');
        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        let connections = []
        for(i = 0; i < deviceArray.length; i++){
            let device = deviceArray[i].id;
            let ports = Object.keys(devices[device].ports);
            for(j = 0; j < ports.length; j++){
                let port = ports[j];
                connections.push([`${devices[device].ports[port].thisDevice} ${devices[device].ports[port].thisPort}`,`${devices[device].ports[port].connectedDevice} ${devices[device].ports[port].connectedPort}`])
            }
        }
        // check for duplicate connections
        for(i = 0; i < connections.length; i++){
            for(j = 0; j < connections.length; j++){
                if(connections[i][0] == connections[j][1] && connections[i][1] == connections[j][0]){
                    connections.splice(j, 1);
                }
            }
        }

        // create the lines based on the connections array, the lines start and end in the center of the device
        for(i = 0; i < connections.length; i++){
            let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            let startDevice = connections[i][0].split(' ')[0];
            let startPort = connections[i][0].split(' ')[1];

            let endDevice = connections[i][1].split(' ')[0];
            let endPort = connections[i][1].split(' ')[1];

            
            let startDeviceX = document.getElementById(startDevice).offsetLeft + 25;
            let startDeviceY = document.getElementById(startDevice).offsetTop + 25;

            let endDeviceX = document.getElementById(endDevice).offsetLeft + 25;
            let endDeviceY = document.getElementById(endDevice).offsetTop + 25;

            
            let angle = Math.atan2(endDeviceY - startDeviceY, endDeviceX - startDeviceX) * 180 / Math.PI;
            let overlap = false;
            let lines = svg.getElementsByTagName('line');
            // check if the line overlaps with another line
            for(j = 0; j < lines.length; j++){
                let lineX1 = lines[j].getAttribute('x1');
                let lineY1 = lines[j].getAttribute('y1');
                let lineX2 = lines[j].getAttribute('x2');
                let lineY2 = lines[j].getAttribute('y2');
                let lineAngle = Math.atan2(lineY2 - lineY1, lineX2 - lineX1) * 180 / Math.PI;
                if(angle == lineAngle){
                    overlap = true;
                }
            }

            line.id = `${startDevice} ${startPort} ${endDevice} ${endPort}`;




            if(overlap){
                startDeviceY += 15;
                endDeviceY += 15;
            }

            line.setAttribute('x1', startDeviceX);
            line.setAttribute('y1', startDeviceY);
            line.setAttribute('x2', endDeviceX);
            line.setAttribute('y2', endDeviceY);

            
            line.setAttribute('stroke', 'black');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);

            // put a circle at each end of the line, just outside of the device
            // get the angle of the line


            let startCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            startCircle.setAttribute('cx', startDeviceX + 50 * Math.cos(angle * Math.PI / 180));
            startCircle.setAttribute('cy', startDeviceY + 50 * Math.sin(angle * Math.PI / 180));
            startCircle.setAttribute('r', '5');


            let endCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            endCircle.setAttribute('cx', endDeviceX - 50 * Math.cos(angle * Math.PI / 180));
            endCircle.setAttribute('cy', endDeviceY - 50 * Math.sin(angle * Math.PI / 180));
            endCircle.setAttribute('r', '5');



            let portType = devices[startDevice].ports[startPort].thisPortType

            if(portType == 'designated'){
                startCircle.setAttribute('fill', 'cornflowerblue');
            } else if(portType == 'root'){
                startCircle.setAttribute('fill', 'gold');
            } else if(portType == 'non-designated'){
                startCircle.setAttribute('fill', 'red');
            } else {
                startCircle.setAttribute('fill', 'black');
            }
            svg.appendChild(startCircle);


            portType = devices[endDevice].ports[endPort].thisPortType;
            if(portType == 'designated'){
                endCircle.setAttribute('fill', 'cornflowerblue');
            } else if(portType == 'root'){
                endCircle.setAttribute('fill', 'gold');
            } else if(portType == 'non-designated'){
                endCircle.setAttribute('fill', 'red');
            } else {
                endCircle.setAttribute('fill', 'black');
            }
            svg.appendChild(endCircle);

            // remove duplicate circles
            let circles = svg.getElementsByTagName('circle');
            for(j = 0; j < circles.length; j++){
                for(k = 0; k < circles.length; k++){
                    if(j != k){
                        if(circles[j].getAttribute('cx') == circles[k].getAttribute('cx') && circles[j].getAttribute('cy') == circles[k].getAttribute('cy')){
                            circles[k].remove();
                        }
                    }
                }
            }

            // let each circle have the ID of `port ${startDevice} ${startPort}` or `port ${endDevice} ${endPort}`
            let startCircleID = `port ${startDevice} ${startPort}`;
            let endCircleID = `port ${endDevice} ${endPort}`;

            startCircle.setAttribute('id', startCircleID);
            endCircle.setAttribute('id', endCircleID);

            // label the circles with the port name
            let startLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            startLabel.setAttribute('x', startDeviceX + 50 * Math.cos(angle * Math.PI / 180));
            startLabel.setAttribute('y', startDeviceY + 50 * Math.sin(angle * Math.PI / 180));
            startLabel.setAttribute('text-anchor', 'middle');
            startLabel.setAttribute('alignment-baseline', 'middle');
            startLabel.setAttribute('font-size', '12');
            startLabel.setAttribute('font-family', 'monospace');
            startLabel.innerHTML = startPort;

            let endLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            endLabel.setAttribute('x', endDeviceX - 50 * Math.cos(angle * Math.PI / 180));
            endLabel.setAttribute('y', endDeviceY - 50 * Math.sin(angle * Math.PI / 180));
            endLabel.setAttribute('text-anchor', 'middle');
            endLabel.setAttribute('alignment-baseline', 'middle');
            endLabel.setAttribute('font-size', '12');
            endLabel.setAttribute('font-family', 'monospace');
            endLabel.innerHTML = endPort;
            

            // move the labels so they are above the circles
            startLabel.setAttribute('y', startLabel.getAttribute('y') - 10);
            endLabel.setAttribute('y', endLabel.getAttribute('y') - 10);

            // fix the labels that have been offset
            if(startLabel.getAttribute('y') < 0){
                startLabel.setAttribute('y', startLabel.getAttribute('y') + 20);
            }


            svg.appendChild(startLabel);
            svg.appendChild(endLabel);
            

            
        
        
        }

        // check all lines for overlapping, if they are overlapping, move the end point of the line to the side

        lineDrawer.appendChild(svg);
    }



    // file:///C:/Users/aarogozin2026/Downloads/STP_Spanning_Tree_Protocol.pdf
    // https://techhub.hpe.com/eginfolib/networking/docs/switches/7500/5200-1938a_l2-lan_cg/content/495503520.htm

</script>