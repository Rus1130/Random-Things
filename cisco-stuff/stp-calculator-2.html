<style>
    .button {
        outline: 1px black solid;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        height: 50px;
        width: 130px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-family: monospace;
    }

    #display {
        height: 600px;
        width: 600px;
        position: absolute;
        top: 10px;
        right: 10px;
        outline: 1px black solid;
    }

    #input {
        border-radius: 0%;
        position: absolute;
        right: 10px;
        top: 625px;
        width: 601px;
        height: 150px;
        font-family: monospace;
        font-size: 12px;
        resize: none;
        caret-color: black;
    }

    textarea {
        resize: none;
    }
    textarea:focus {
        outline: none;
    }
</style>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.0/svg.min.js"></script>
    <script src="../node_modules/@svgdotjs/svg.draggable.js/dist/svg.draggable.min.js"></script>
</head>
<body>
    <div class="button" id="calculate">Calculate STP</div><br>
    <div class="button" onclick="window.open('stp-calc-2-docs.txt','_blank')">Open Docs</div>
    <div id="display"></div>
    <textarea id="input">device sw1 32769 a.a.a.a
device sw2 16384 b.b.b.b
device sw3 4096 c.c.c.c
connect sw1 g0/1 sw2 g0/0
connect sw1 g0/2 sw2 g0/2
connect sw2 g0/1 sw3 g0/0
connect sw3 g0/1 sw1 g0/0
    </textarea>
</body>
<script type="module">
    let calculateButton = document.getElementById("calculate");

    var draw = SVG().addTo('#display').size(600, 600)

    class Device {
        constructor(name, mac, priority) {
            this.name = name;
            this.mac = mac;
            this.priority = priority;
            this.svg = null;
            this.rootBridge = false;
            this.ports = {};

            Device.devices[this.name] = this;
        }

        static abbreviations = {
            "e": ["Ethernet", 100],
            "f": ["FastEthernet", 19],
            "g": ["GigabitEthernet", 4],
            "t": ["TenGigabitEthernet", 2]
        }

        static devices = {}
        static connections = []
        static lines = []

        setSVG(svg){
            this.svg = svg;
        }

        collapseMacAddress(){
            let mac = this.mac.split(".");
            let collapsedMac = 0;
            for(let i = 0; i < mac.length; i++){
                collapsedMac += parseInt(mac[i], 16) * Math.pow(2, (mac.length - i - 1) * 8);
            }
            return collapsedMac;
        }

        addPort(port) {
            if(Object.keys(this.ports).includes(port)) throw new Error("Port already exists");
            this.ports[port] = {
                name: port,
                rootPort: false,
                type: undefined,
                svg: null,
                connected: {
                    device: undefined,
                    port: undefined
                }
            }
        }

        static connect(thisDevice, thisPort, connectedDevice, connectedPort){
            if(!Object.keys(Device.devices).includes(thisDevice)) throw new Error(`thisDevice ${thisDevice} does not exist`);
            if(!Object.keys(Device.devices).includes(connectedDevice)) throw new Error(`connectedDevice ${connectedDevice} does not exist`);

            if(!Object.keys(Device.devices[connectedDevice].ports).includes(connectedPort)) throw new Error(`connectedPort ${connectedPort} does not exist`);
            if(!Object.keys(Device.devices[thisDevice].ports).includes(thisPort)) throw new Error(`thisPort ${thisPort} does not exist`);


            Device.devices[thisDevice].ports[thisPort].connected.device = connectedDevice;
            Device.devices[thisDevice].ports[thisPort].connected.port = connectedPort;

            Device.devices[connectedDevice].ports[connectedPort].connected.device = thisDevice;
            Device.devices[connectedDevice].ports[connectedPort].connected.port = thisPort;

            Device.connections.push([thisDevice, thisPort, connectedDevice, connectedPort]);
        }
    }

    function parse(){
        let input = document.getElementById("input").value.split("\n");

        let parseError = false;

        for(let i = 0; i < input.length; i++){
            let line = input[i].split(" ");
            let command = line[0];

            if(command == 'device'){
                if(line.length != 4){
                    alert(`Invalid device command on line ${i + 1}`);
                    parseError = true;
                    return;
                }
                 
                if(Object.keys(Device.devices).includes(line[1])){
                    alert(`Device ${line[1]} already exists`);
                    parseError = true;
                    return;
                }

                new Device(line[1], line[2], line[3]);
            }

            if(command == 'connect'){

                let device1 = line[1];
                let port1 = line[2];
                let device2 = line[3];
                let port2 = line[4];

                if(line.length != 5){
                    alert(`Invalid port command on line ${i + 1}`);
                    parseError = true;
                    return;
                }
                if(!Object.keys(Device.devices).includes(line[1])){
                    alert(`Device ${device1} does not exist`);
                    parseError = true;
                    return;
                }
                if(!Object.keys(Device.devices).includes(line[3])){
                    alert(`Device ${device2} does not exist`);
                    parseError = true;
                    return;
                }

                // check if the ports exist. if they dont, create them
                if(!Object.keys(Device.devices[device1].ports).includes(port1)){
                    Device.devices[device1].addPort(port1);
                }
                if(!Object.keys(Device.devices[device2].ports).includes(port2)){
                    Device.devices[device2].addPort(port2);
                }

                if(Device.devices[device1].ports[port1].connected.device != null){
                    alert(`Port ${port1} on device ${device1} is already connected`);
                    parseError = true;
                    return;
                }

                if(Device.devices[device2].ports[port2].connected.device != null){
                    alert(`Port ${port2} on device ${device2} is already connected`);
                    parseError = true;
                    return;
                }   

                Device.devices[device1].ports[port1].connected.device = device2;
                Device.devices[device1].ports[port1].connected.port = port2;

                Device.devices[device2].ports[port2].connected.device = device1;
                Device.devices[device2].ports[port2].connected.port = port1;

                let offset = 0;

                // check if there is already a connection between device1 and device2. for each previous connection, increase offset
                for(let i = 0; i < Device.connections.length; i++){
                    let connection = Device.connections[i];
                    if(connection[0] == device1 && connection[2] == device2 || connection[0] == device2 && connection[2] == device1){
                        offset++;
                    }
                }

                Device.connections.push([device1, port1, device2, port2, offset]);
            }

            if(command == 'port'){
                if(line.length != 3){
                    alert(`Invalid port command on line ${i + 1}`);
                    parseError = true;
                    return;
                }

                let device = line[1];
                let port = line[2];

                if(!Object.keys(Device.devices).includes(device)){
                    alert(`Device ${device} does not exist`);
                    parseError = true;
                    return;
                }

                if(Object.keys(Device.devices[device].ports).includes(port)){
                    alert(`Port ${port} on device ${device} already exists`);
                    parseError = true;
                    return;
                }

                if(!Object.keys(Device.devices[device].ports).includes(port)){
                    Device.devices[device].addPort(port);
                }
            }
        }

        return parseError;
    }

    let deviceGraphics = []

    let mouseX = 0;
    let mouseY = 0;

    document.addEventListener("mousemove", function(e){
        mouseX = e.clientX;
        mouseY = e.clientY;
    })

    calculateButton.addEventListener("click", function(e){
        // delete all svgs
        draw.clear();
        parse()
        let devices = Object.keys(Device.devices);
        for(let i = 0; i < devices.length; i++){
            let device = Device.devices[devices[i]];

            let rect = draw.rect(70, 70).attr({ fill: '#fff' }).center(300, 300).radius(5).stroke({ width: 2, color: '#000' })
            let text = draw.text(device.name).move(270, 270).font({ size: 15, family: 'monospace' }).center(300, 300)

            let group = draw.group();
            group.add(rect);
            group.add(text);

            device.setSVG(group);

            group.draggable();
            //console.log(Device.connections)
        }
        for(let i = 0; i < Device.connections.length; i++){
            let connection = Device.connections[i];
            let device1 = Device.devices[connection[0]];
            let device2 = Device.devices[connection[2]];

            let port1 = device1.ports[connection[1]];
            let port2 = device2.ports[connection[3]];

            let offset = connection[4];

            let line = draw.line(0, 0, 0, 0).stroke({ width: 2, color: '#000' });
            line.back()
            Device.lines.push(line);

            device1.svg.on("dragmove", function(){
                // get all lines connected between device1 and device2
                line.plot(device1.svg.cx(), device1.svg.cy() + offset * 20, device2.svg.cx(), device2.svg.cy() + offset * 20);
            })

            device2.svg.on("dragmove", function(){
                line.plot(device2.svg.cx(), device2.svg.cy() + offset * 20, device1.svg.cx(), device1.svg.cy() + offset * 20);
            })
        }
        Device.devices = {};
        Device.lines = [];
        Device.connections = [];
    })
</script>