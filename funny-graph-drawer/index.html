<style>
    #graph {
        border: 1px solid black;
        /*
        make the width and height always the same
        */
        width: 500px;
        height: 500px;
        position: absolute;
        left: 5px;
        top: 25%;

        display: grid;
    }
    #input {
        resize: none;
        width: 500px;
        height: 170px;
        position: absolute;
        left: 5px;
    }
    #input:focus {
        outline: none;
    }
    #blocker {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        font-size: 100px;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #draw-button {
        height: 50px;
        width: 100px;
        border: 1px solid black;
        position: absolute;
        left: 520px;
    }
</style>
<head>
    <script src="https://unpkg.com/mathjs@11.4.0/lib/browser/math.js"></script>
    <script src='https://unpkg.com/paralleljs@1.0/lib/parallel.js'></script>
</head>
<body>
    <textarea id="input">x = -20</textarea>
    <div id="graph"></div>
    <div id="draw-button" onclick="draw(input.value)"></div>
</body>
<script>
    // make this a module
    const graph = document.getElementById("graph");
    const input = document.getElementById("input");

    const colors = ['#000000', '#0000FF', '#00FF00', '#FF0000', '#00FFFF', '#FF00FF', '#FFFF00', "#6042A6"];


    const xCellMax = 25;
    const yCellMax = 25;
    const precision = 8;
    const iterator = 1 / (precision / 2);

    const parser = math.parser()

    let yMin = -yCellMax;
    let yMax = yCellMax;
    let xMin = -xCellMax;
    let xMax = xCellMax;

    // get the graph style
    graph.style.gridTemplateColumns = `repeat(${xCellMax * precision + 1}, 1fr)`;
    graph.style.gridTemplateRows = `repeat(${yCellMax * precision + 1}, 1fr)`;


    function clean(string){
        return Array(Array(string.trim()).reverse().join().trim()).reverse().join();
    }

    // '#2D70B3'
    // '#388C46'
    // '#FA7E19'

    let setupComplete = false;

    const sectors = true;

    function setup(){
        for(let y = yMax; y >= yMin; y -= iterator){
            for(let x = xMin; x <= xMax; x += iterator){
                let div = document.createElement('div');
                div.id = `${x},${y}`;
                if(sectors){
                    if(x >= -xCellMax && x <= -xCellMax/2 && y >= yCellMax/2){ // top left top left
                        div.style.backgroundColor = '#C74440'
                    } else if(x >= 0 && x <= xCellMax/2 && y >= yCellMax/2){ // top right top left
                        div.style.backgroundColor = '#C74440'
                    } else if(x >= -xCellMax && x <= -xCellMax/2 && y >= -yCellMax/2 && y <= 0){ // bottom left top left
                        div.style.backgroundColor = '#C74440'
                    } else if(x >= 0 && x <= xCellMax/2 && y >= -yCellMax/2 && y <= 0){ // bottom right top left
                        div.style.backgroundColor = '#C74440'
                    }


                    if(x >= -xCellMax/2 && x <= 0 && y >= yCellMax/2){ // top left top right
                        div.style.backgroundColor = '#2D70B3'
                    } else if(x >= xCellMax/2 && x <= xCellMax && y >= yCellMax/2){ // top right top right
                        div.style.backgroundColor = '#2D70B3'
                    } else if(x >= -xCellMax/2 && x <= 0 && y >= -yCellMax/2 && y <= 0){ // bottom left top right
                        div.style.backgroundColor = '#2D70B3'
                    } else if(x >= xCellMax/2 && x <= xCellMax && y >= -yCellMax/2 && y <= 0){ // bottom right top right
                        div.style.backgroundColor = '#2D70B3'
                    }

                    if(x >= -xCellMax && x < -xCellMax/2 && y < yCellMax/2 && y > 0){ // top left bottom left
                        div.style.backgroundColor = '#388C46'
                    } else if(x > 0 && x < xCellMax/2 && y < yCellMax/2 && y > 0){ // top right bottom left
                        div.style.backgroundColor = '#388C46'
                    } else if(x >= -xCellMax && x < -xCellMax/2 && y <= -yCellMax/2 && y < -yCellMax/2){ // bottom left bottom left
                        div.style.backgroundColor = '#388C46'
                    } else if(x > 0 && x < xCellMax/2 && y <= -yCellMax/2 && y < -yCellMax/2){ // bottom right bottom left
                        div.style.backgroundColor = '#388C46'
                    }

                    if(x >= -xCellMax/2 && x <= 0 && y < yCellMax/2 && y > 0){ // top left bottom right
                        div.style.backgroundColor = '#FA7E19'
                    } else if(x >= xCellMax/2 && x <= xCellMax && y < yCellMax/2 && y > 0){ // top right bottom right
                        div.style.backgroundColor = '#FA7E19'
                    } else if(x >= -xCellMax/2 && x <= 0 && y <= -yCellMax/2 && y < -yCellMax/2){ // bottom left bottom right
                        div.style.backgroundColor = '#FA7E19'
                    } else if(x >= xCellMax/2 && x <= xCellMax && y <= -yCellMax/2 && y < -yCellMax/2){ // bottom right bottom right
                        div.style.backgroundColor = '#FA7E19'
                    }
                }






                if((y == 0 && x % 2 == 0) || (x == 0 && y % 2 == 0)){
                    div.style.backgroundColor = 'black';
                }
                graph.appendChild(div);
            }
        }
        setupComplete = true;
    }

    const iterations = {
        x: 0,
        y: 0,
        totalX: ((xCellMax * precision) * (yCellMax * precision)) + (yCellMax * precision * 2) + 1,
        totalY: (yCellMax * precision)
    }

    let starttime = 0;

    function templateDraw(x, y, input){
        let div = document.getElementById(`${x},${y}`);
                        
        let left = clean(input.split('=')[0]);
        let right = math.evaluate(clean(input.split('=')[1]), {x: x, y: y});

        if(left == 'x'){
            if(x == right){
                div.setAttribute('plot', 'true');
                div.setAttribute('previousColor', div.style.backgroundColor);
                div.style.backgroundColor = colors[0];
            }
        } else if(left == 'y'){
            if(y == right){
                div.setAttribute('plot', 'true');
                div.setAttribute('previousColor', div.style.backgroundColor);
                div.style.backgroundColor = colors[0];
            }
        }
    }

    const drawFunctions = {
        top: {
            left: {
                top: {
                    left: function(input){
                        starttime = Date.now();
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= -xCellMax && x <= -xCellMax/2 && y >= yCellMax/2){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top left top left done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 10})} ms to s`)})`);
                    },
                    right: function(input){
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= -xCellMax/2 && x <= 0 && y >= yCellMax/2){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top left top right done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 5})} ms to s`)})`);
                    },
                },
                bottom: {
                    left: function(input){
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= -xCellMax && x < -xCellMax/2 && y < yCellMax/2 && y > 0){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top left bottom left done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 10})} ms to s`)})`);
                    },
                    right: function(input){
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= -xCellMax/2 && x <= 0 && y < yCellMax/2 && y > 0){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top left bottom right done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 10})} ms to s`)})`);
                    }
                }
            },
            right: {
                top: {
                    left: function(input){
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= 0 && x <= xCellMax/2 && y >= yCellMax/2){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top right top left done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 10})} ms to s`)})`);
                    },
                    right: function(input){
                        for(let y = yMax; y >= yMin; y -= iterator){
                            for(let x = xMin; x <= xMax; x += iterator){
                                if(x >= xCellMax/2 && x <= xCellMax && y >= yCellMax/2){
                                    templateDraw(x, y, input);
                                }
                            }
                        }
                        console.log(`top right top right done (${parser.evaluate(`${math.format(Date.now() - startTime, {precision: 10})} ms to s`)})`);
                    }
                },
                bottom: {
                    left: function(input){

                    },
                    right: function(input){

                    }
                }
            }
        },
        bottom: {
            left: {
                top: {
                    left: function(input){

                    },
                    right: function(input){

                    }
                },
                bottom: {
                    left: function(input){

                    },
                    right: function(input){

                    }
                }
            },
            right: {
                top: {
                    left: function(input){

                    },
                    right: function(input){

                    }
                },
                bottom: {
                    left: function(input){

                    },
                    right: function(input){

                    }
                }
            }
        }
    }


    async function draw(input){
        if(!setupComplete){
            return console.warn('setup not complete!')
        } else {
            let previouslyDrawn = document.querySelectorAll('[plot="true"]');
            for(i = 0; i < previouslyDrawn.length; i++){
                previouslyDrawn[i].style.backgroundColor = previouslyDrawn[i].getAttribute('previousColor');
                previouslyDrawn[i].setAttribute('plot', 'false');
            }
            startTime = Date.now();

            const p = new Parallel([
                drawFunctions.top.left.top.left(input),
                drawFunctions.top.left.top.right(input),
                drawFunctions.top.left.bottom.left(input),
                drawFunctions.top.left.bottom.right(input),
                
                drawFunctions.top.right.top.left(input),
                drawFunctions.top.right.top.right(input),
            ]);
            try {
                p.spawn()
            } catch {
                console.warn(`done in ${parser.evaluate(`${Date.now() - startTime} ms to s`)}`);
                return
            }
        }
        

    }

    window.onload = function(){
        setup()
    }


    // https://www.youtube.com/watch?v=JnCkF62gkOY
    // total iterations for 4 precision:  

</script>