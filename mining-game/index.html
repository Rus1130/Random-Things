<style>
    #buildMenu {
        left: 50px;
        position: absolute;
        bottom: -110px;
        width: calc(100% - 100px);
        height: 100px;
        background-color: white;
        border: 1px black solid;
        z-index: 100;
    }
</style>
<head>
    <script src="two.js"></script>
</head>
<body>
    <div id="buildMenu"></div>
    <div id="two"></div>
</body>
<script>
    var two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.getElementById('two'));

    const buildMenu = document.getElementById('buildMenu')

    const gameData = {
        gridLines: [],
        zoom: 0.5,
        zoomMultiplier: 40,
        mouseX: 0,
        mouseY: 0,
        buildMode: false,
        objects: [],
        keys: {},
        selectedObject: null,
        mouselock: false,
    }

    placementPreview = two.makeRectangle(0, 0, gameData.zoomMultiplier * gameData.zoom, gameData.zoomMultiplier * gameData.zoom);
    placementPreview.fill = 'black';
    placementPreview.opacity = 0.3;
    placementPreview.id = 'placementPreview';

    gameData.objects.push(placementPreview);


    function getPreviewCoordinates(){
        return {x: placementPreview.translation.x, y: placementPreview.translation.y};
    }



    const place = {
        circle(x, y){
            let circle = two.makeCircle(x, y, gameData.zoomMultiplier * gameData.zoom / 2);
            circle.fill = 'red';
            circle.objectType = 'circle';
            gameData.objects.push(circle);
        },
        square(x, y){
            let square = two.makeRectangle(x, y, gameData.zoomMultiplier * gameData.zoom, gameData.zoomMultiplier * gameData.zoom);
            square.fill = 'blue';
            square.objectType = 'square';
            gameData.objects.push(square);
        },
        conveyer(x, y){
            let conveyer1 = two.makeRectangle(x - (gameData.zoomMultiplier * gameData.zoom / 2), y, 1, gameData.zoomMultiplier * gameData.zoom);
            let conveyer2 = two.makeRectangle(x + (gameData.zoomMultiplier * gameData.zoom / 2), y, 1, gameData.zoomMultiplier * gameData.zoom);
            let conveyer = two.makeGroup(conveyer1, conveyer2);
            conveyer.objectType = 'conveyer';
            gameData.objects.push(conveyer);
        }
    }

    document.onmousemove = e => {
        if(gameData.mouselock) return;
        gameData.mouseX = e.clientX;
        gameData.mouseY = e.clientY;
        document.body.style.cursor = 'default';
    }

    function setGridLines(remove){
        if(remove){
            gameData.gridLines.forEach(line => {
                line.remove();
            });
        }
        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerWidth; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(i, 0, i, window.innerHeight);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'horizontal';

            gameData.gridLines.push(line);
        }

        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerHeight; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(0, i, window.innerWidth, i);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'vertical';

            gameData.gridLines.push(line);
        }
    }

    function removeGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
    }

    
    function redrawAllObjects(){
        placementPreview.width = gameData.zoomMultiplier * gameData.zoom;
        placementPreview.height = gameData.zoomMultiplier * gameData.zoom;

        gameData.objects.forEach(object => {

            let x = object.translation.x;
            let y = object.translation.y;

            x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
            y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);

            object.translation.set(x, y);
        })

    }

    let buildMenuKeyframes = [
        {bottom: '50px'},
    ]

    let buildMenuKeyframeOptions = {
        duration: 90,
        iterations: 1,
        fill: 'forwards',
        easing: 'ease-in-out',
    }

    document.onkeydown = e => {
        let key = e.key
        gameData.keys[key] = true;
        if(gameData.keys['ArrowUp']){
            gameData.mouseY -= gameData.zoomMultiplier * gameData.zoom;
            document.body.style.cursor = 'none';
        }
        if(gameData.keys['ArrowDown']){
            gameData.mouseY += gameData.zoomMultiplier * gameData.zoom;
            document.body.style.cursor = 'none';
        }
        if(gameData.keys['ArrowLeft']){
            gameData.mouseX -= gameData.zoomMultiplier * gameData.zoom;
            document.body.style.cursor = 'none';
        }
        if(gameData.keys['ArrowRight']){
            gameData.mouseX += gameData.zoomMultiplier * gameData.zoom;
            document.body.style.cursor = 'none';
        }

        if(gameData.keys['m']){
            gameData.mouselock = !gameData.mouselock;
        }
        if(gameData.keys['g']){
            gameData.buildMode = !gameData.buildMode;
            if(gameData.buildMode){
                setGridLines();
                // buildMenuKeyframes[0].bottom = '50px';
                // buildMenu.animate(buildMenuKeyframes, buildMenuKeyframeOptions);
            } else {
                removeGridLines();
                // buildMenuKeyframes[0].bottom = '-110px';
                // buildMenu.animate(buildMenuKeyframes, buildMenuKeyframeOptions);
            }
        }
        if(gameData.keys['e']){
            let previewPos = getPreviewCoordinates()
            let checkObject = gameData.objects.find(object => { 
                return object.id !== 'placementPreview' && object.translation.x == previewPos.x && object.translation.y == previewPos.y;
            });
            if(checkObject == undefined && gameData.selectedObject !== null){
                place[gameData.selectedObject](previewPos.x, previewPos.y);
            }
            
            
            // place object ============
        }
        if(gameData.keys['1']){
            gameData.selectedObject = 'conveyer';
        }
        if(gameData.keys['2']){
            gameData.selectedObject = 'square';
        }
    }

    document.onkeyup = e => {
        let key = e.key
        gameData.keys[key] = false;
    }

    function update(fc){
        let x = gameData.mouseX;
        let y = gameData.mouseY;

        if(gameData.buildMode){
            setGridLines(true);
        }

        x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        
        placementPreview.translation.set(x, y);
        placementPreview.width = gameData.zoomMultiplier * gameData.zoom;
        placementPreview.height = gameData.zoomMultiplier * gameData.zoom;
    }


    two.bind('update', function(frameCount) {
        update(frameCount);
    })

    window.onresize = e => {
        if(gameData.buildMode){
            setGridLines();
        }
        redrawAllObjects();
    }


    /*
    controls:
    ArrowUp: zoom in
    ArrowDown: zoom out
    d: toggle build mode

    1-3: select different shapes
    e: place object


    */
</script>