<style>
    #buildMenu {
        left: 50px;
        position: absolute;
        bottom: -110px;
        width: calc(100% - 100px);
        height: 100px;
        background-color: white;
        border: 1px black solid;
        z-index: 100;
    }
</style>
<head>
    <script src="two.js"></script>
</head>
<body>
    <div id="buildMenu"></div>
    <div id="two"></div>
</body>
<script>
    var two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.getElementById('two'));

    const buildMenu = document.getElementById('buildMenu')

    const gameData = {
        gridLines: [],
        zoom: 0.7,
        zoomMultiplier: 40,
        mouseX: 0,
        mouseY: 0,
        buildMode: false,
        objects: [],
        keys: {},
        selectedObject: null,
    }

    placementPreview = two.makeRectangle(0, 0, gameData.zoomMultiplier * gameData.zoom, gameData.zoomMultiplier * gameData.zoom);
    placementPreview.fill = 'black';
    placementPreview.opacity = 0.3;

    gameData.objects.push(placementPreview);


    function getPreviewCoordinates(){
        return {x: placementPreview.translation.x, y: placementPreview.translation.y};
    }



    const place = {
        circle(x, y, radius){
            let circle = two.makeCircle(x, y, radius);
            circle.fill = 'red';
            circle.objectType = 'circle';
            gameData.objects.push(circle);
        },
        square(x, y, width, height){
            let square = two.makeRectangle(x, y, width, height);
            square.fill = 'blue';
            square.objectType = 'square';
            gameData.objects.push(square);
        },
        diamond(x, y, width, height){
            let diamond = two.square(x, y, width, height);
            square.translation.rotate(Math.PI / 4);
            diamond.fill = 'green';
            diamond.objectType = 'diamond';
            gameData.objects.push(diamond);
        }
    }

    let zoomText = two.makeText("Zoom: " + gameData.zoom, window.innerWidth - 120, 20, {
        size: 20,
        family: 'Arial',
        fill: 'black',
        alignment: 'left',
    });

    document.onmousemove = e => {
        gameData.mouseX = e.clientX;
        gameData.mouseY = e.clientY;
    }

    function setGridLines(remove){
        if(remove){
            gameData.gridLines.forEach(line => {
                line.remove();
            });
        }
        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerWidth; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(i, 0, i, window.innerHeight);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'horizontal';

            gameData.gridLines.push(line);
        }

        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerHeight; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(0, i, window.innerWidth, i);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'vertical';

            gameData.gridLines.push(line);
        }
    }

    function removeGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
    }

    
    function redrawAllObjects(){
        placementPreview.width = gameData.zoomMultiplier * gameData.zoom;
        placementPreview.height = gameData.zoomMultiplier * gameData.zoom;

        gameData.objects.forEach(object => {

            let x = object.translation.x;
            let y = object.translation.y;

            x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
            y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);

            object.translation.set(x, y);

            if(object.objectType == 'square' || object.objectType == 'diamond'){
                object.width = gameData.zoomMultiplier * gameData.zoom;
                object.height = gameData.zoomMultiplier * gameData.zoom;
            }

            if(object.objectType == 'circle'){
                object.radius = gameData.zoomMultiplier * gameData.zoom / 2;
            }
        })

    }

    let buildMenuKeyframes = [
        {bottom: '50px'},
    ]

    let buildMenuKeyframeOptions = {
        duration: 90,
        iterations: 1,
        fill: 'forwards',
        easing: 'ease-in-out',
    }

    document.onkeydown = e => {
        let key = e.key
        gameData.keys[key] = true;

        if(gameData.keys['ArrowUp']){
            gameData.zoom += 0.1;
        } 
        if(gameData.keys['ArrowDown']){
            if(gameData.zoom > -0.1){
                gameData.zoom -= 0.1;
            }
        } 
        if(gameData.keys['d']){
            gameData.buildMode = !gameData.buildMode;
            if(gameData.buildMode){
                setGridLines();
                buildMenuKeyframes[0].bottom = '50px';
                buildMenu.animate(buildMenuKeyframes, buildMenuKeyframeOptions);
            } else {
                removeGridLines();
                buildMenuKeyframes[0].bottom = '-110px';
                buildMenu.animate(buildMenuKeyframes, buildMenuKeyframeOptions);
            }
        }
        if(gameData.buildMode){
            if(gameData.keys['e']){
                let previewPos = getPreviewCoordinates()
                let checkObject = gameData.objects.find(object => {
                    return object.translation.x == previewPos.x && object.translation.y == previewPos.y;
                });
                
                // place object ============
            }
            if(gameData.keys['1']){
                gameData.selectedObject = 'circle';
            }
        }
    }

    document.onkeyup = e => {
        let key = e.key
        gameData.keys[key] = false;
    }

    function update(fc){
        let x = gameData.mouseX;
        let y = gameData.mouseY;

        if(gameData.buildMode){
            setGridLines(true);
        }

        x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        
        placementPreview.translation.set(x, y);
        placementPreview.width = gameData.zoomMultiplier * gameData.zoom;
        placementPreview.height = gameData.zoomMultiplier * gameData.zoom;

        zoomText.translation.set(window.innerWidth - 120, 20);
        zoomText.value = "Zoom: " + (gameData.zoom + 0.3).toFixed(1) + "x";
    }


    two.bind('update', function(frameCount) {
        update(frameCount);
    })

    window.onresize = e => {
        if(gameData.buildMode){
            setGridLines();
        }
        redrawAllObjects();
    }


    /*
    controls:
    ArrowUp: zoom in
    ArrowDown: zoom out
    d: toggle build mode

    1-3: select different shapes
    e: place object


    */
</script>