<style>

</style>
<head>

</head>
<body>
    <script src="two.js"></script>
</body>
<script>
    var two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.body);

    const gameData = {
        gridLines: [],
        zoom: 0.7,
        zoomMultiplier: 40,
        mouseX: 0,
        mouseY: 0,
        redrawGrid: false,
        buildMode: false,
        objects: [],
        keys: {},
        showGrid: false,
    }


    placementPreview = two.makeRectangle(0, 0, gameData.zoomMultiplier * gameData.zoom, gameData.zoomMultiplier * gameData.zoom);
    gameData.objects.push(placementPreview);
    placementPreview.fill = 'black';
    placementPreview.opacity = 0.3;


    function getPreviewCoordinates(){
        return {x: placementPreview.translation.x, y: placementPreview.translation.y};
    }



    const place = {
        circle(x, y, radius){
            let circle = two.makeCircle(x, y, radius);
            circle.fill = 'red';
            circle.objectType = 'circle';
            gameData.objects.push(circle);
        },
    }

    let zoomText = two.makeText("Zoom: " + gameData.zoom, window.innerWidth - 120, 20, {
        size: 20,
        family: 'Arial',
        fill: 'black',
        alignment: 'left',
    });

    document.onmousemove = e => {
        gameData.mouseX = e.clientX;
        gameData.mouseY = e.clientY;
    }

    let buildMenu;

    function setGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerWidth; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(i, 0, i, window.innerHeight);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'horizontal';

            gameData.gridLines.push(line);
        }

        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerHeight; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(0, i, window.innerWidth, i);
            line.stroke = 'black';
            line.linewidth = 1;
            line.direction = 'vertical';

            gameData.gridLines.push(line);
        }


        // add animation to build menu
        buildMenu = two.makeRectangle(window.innerWidth / 2, window.innerHeight - 70, window.innerWidth - 100, 100);
        buildMenu.fill = 'white';
        buildMenu.opacity = 1;
    }

    function removeGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
    }

    
    function redrawAllObjects(){
        placementPreview.width = gameData.zoomMultiplier * gameData.zoom;
        placementPreview.height = gameData.zoomMultiplier * gameData.zoom;

        gameData.objects.forEach(object => {

            let x = object.translation.x;
            let y = object.translation.y;

            x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
            y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);

            object.translation.set(x, y);

            if(object.objectType == 'circle'){
                object.radius = gameData.zoomMultiplier * gameData.zoom / 2;
            }
        })


        
        gameData.redrawGrid = false;
    }

    document.onkeydown = e => {
        let key = e.key
        gameData.keys[key] = true;

        if(gameData.keys['ArrowUp']){
            gameData.zoom += 0.1;
            gameData.redrawGrid = true;

        } else if(gameData.keys['ArrowDown']){
            if(gameData.zoom > 0.1){
                gameData.zoom -= 0.1;
                gameData.redrawGrid = true;
            }
            gameData.redrawGrid = true;
            
        } else if(gameData.keys['e']){
            gameData.buildMode = !gameData.buildMode;
            if(gameData.buildMode){

            }
        }
    }


    document.onkeyup = e => {
        let key = e.key
        gameData.keys[key] = false;
    }

    function update(fc){
        let x = gameData.mouseX;
        let y = gameData.mouseY;

        // make it snap to grid squares

        x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        
        placementPreview.translation.set(x, y);

        
        placementPreview.radius = gameData.zoom * (gameData.zoomMultiplier / 2);

        if(gameData.redrawGrid){
            if(gameData.showGrid) setGridLines();

            redrawAllObjects()

        } 

        zoomText.translation.set(window.innerWidth - 120, 20);
        zoomText.value = "Zoom: " + (gameData.zoom + 0.3).toFixed(1) + "x";
    }

    function gridUpdate(){
        setGridLines();
    }

    two.bind('update', function(frameCount) {
        update(frameCount);

        if(gameData.buildMode){
            gridUpdate();
        } else {
            removeGridLines();
        }
    })

    window.onresize = e => {
        gameData.redrawGrid = true;
        update();
    }

    if(gameData.showGrid) setGridLines();
</script>