<style>

</style>
<head>

</head>
<body>
    <script src="two.js"></script>
</body>
<script>
    var two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.body);

    const gameData = {
        gridLines: [],
        zoom: 1,
        zoomMultiplier: 40,
        mouseX: 0,
        mouseY: 0,
        redrawGrid: false,
        buildMode: false,
    }

    let placementPreview = two.makeCircle(0, 0, gameData.zoom * (gameData.zoomMultiplier / 2));

    
    let zoomText = two.makeText("Zoom: " + gameData.zoom, 20, window.innerHeight - 20, {
        size: 20,
        family: 'Arial',
        fill: 'black',
        alignment: 'left',
    });

    console.log(zoomText)

    document.onmousemove = e => {
        gameData.mouseX = e.clientX;
        gameData.mouseY = e.clientY;
    }

    function setGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerWidth; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(i, 0, i, window.innerHeight);
            line.stroke = 'black';
            line.linewidth = 1;

            gameData.gridLines.push(line);
        }

        for(let i = -(gameData.zoom * gameData.zoomMultiplier) / 2; i < window.innerHeight; i += (gameData.zoom * gameData.zoomMultiplier)){
            let line = two.makeLine(0, i, window.innerWidth, i);
            line.stroke = 'black';
            line.linewidth = 1;

            gameData.gridLines.push(line);
        }
    }

    function removeGridLines(){
        gameData.gridLines.forEach(line => {
            line.remove();
        });
    }

    document.onkeyup = e => {
        let key = e.key
        if(key == 'ArrowUp'){
            gameData.zoom += 0.1;
            gameData.redrawGrid = true;
        } else if(key == 'ArrowDown'){
            gameData.zoom -= 0.1;
            gameData.redrawGrid = true;
        } else if(key == 'e'){
            gameData.buildMode = !gameData.buildMode;
        }
    }

    function update(fc){
        let x = gameData.mouseX;
        let y = gameData.mouseY;

        // make it snap to grid squares

        x = Math.round(x / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        y = Math.round(y / (gameData.zoomMultiplier * gameData.zoom)) * (gameData.zoomMultiplier * gameData.zoom);
        
        placementPreview.translation.set(x, y);

        
        placementPreview.radius = gameData.zoom * (gameData.zoomMultiplier / 2);

        zoomText.translation.set(20, window.innerHeight - 20);
        zoomText.value = "Zoom: " + gameData.zoom.toFixed(1) + "x";
    }

    function gridUpdate(){
        setGridLines();
    }

    two.bind('update', function(frameCount) {
        update(frameCount);

        if(gameData.buildMode){
            gridUpdate();
        } else {
            removeGridLines();
        }
    })

    window.onresize = e => {
        update();
    }
</script>