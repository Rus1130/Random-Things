<style>
#grid {
    display: grid;
    width: 500px;
    height: 500px;
    grid-gap: 2px;
}
.hidden {
    display: none;
}
</style>
<head>
    <script src="main.js"></script>
</head>
<body>
    <div>type directions() in the console to get started</div>
    <div id="levelDisplay">Level 1 (0/10)</div>
    <div id="partitionRecordsCount">Partition Records: 0</div>
    <div id='dayCounter'>Day 1</div>
    <div id="nextDayCounter">Seconds Until Day End:</div>
    <div id="timer" class="hidden"></div>
    <div id="grid" class="hidden"></div>
</body>
<script>

    const dayCounter = document.getElementById('dayCounter');
    const nextDayCounter = document.getElementById('nextDayCounter');
    const partitionRecordsCount = document.getElementById('partitionRecordsCount');
    const timeLeft = document.getElementById('timer');
    const levelDisplay = document.getElementById('levelDisplay');

    const grid = document.getElementById('grid');

    let partitionRecords = 0;
    let ticks = 0;
    let timeMeasuringTicks = 0;
    let day = 1;

    let level = 1
    let currentExp = 0;
    let expNeeded = 10;

    let currentContracts = {};
    let acceptedContracts = {};

    let lastSoldItem = '';

    // calculate the number of seconds until the next day

    let seconds = Math.round((1200 - (ticks % 1200)) * 125 / 1000);

    nextDayCounter.innerHTML = `Day ${day + 1} in ${seconds} second${seconds == 1 ? '' : 's'}`;

    let paused = false;
    let truePaused = false;
    console.log(contractListArray)
    setInterval(() => {
        if(!paused){
            ticks++;
            partitionRecordsCount.innerHTML = `Partition Records: ${partitionRecords}`;
            for(i = 0; i < contractListArray.length; i++){
                if(day == contractList[i].offerDay){
                    currentContracts[i] = contractList[i]
                }
            }
            if(ticks % 1200 == 0){
                day++;
                dayCounter.innerHTML = `Day ${day}`;
                
            } else {
                seconds = Math.round((1200 - (ticks % 1200)) * 125 / 1000);
                nextDayCounter.innerHTML = `Day ${day + 1} in ${seconds} second${seconds == 1 ? '' : 's'}`;
            }
        }
        if(!truePaused){
            timeMeasuringTicks++;
        }
        while(currentExp >= expNeeded){
            level++;
            currentExp -= expNeeded;
            expNeeded = Math.round(Math.pow(expNeeded, 1.1));
        }
        levelDisplay.innerHTML = `Level ${level} (${currentExp}/${expNeeded})`;
    }, 125);


    function buy(item){
        if(hacking) return `You cannot do this right now!`
        if(level < technicals[item].levelReq) return `You need to be level ${technicals[item].levelReq} to buy this!`;
        if(partitionRecords >= shop[item].price){
            partitionRecords -= shop[item].price;
            if(inventory[switcher.StL[item]]){
                inventory[switcher.StL[item]]++;
            } else {
                inventory[switcher.StL[item]] = 1;
            }
            return `Successfully bought ${item}!`;
        } else {
            return `You do not have enough Partition Records to buy ${item}.`
        }
    }

    function sell(item){
        if(hacking) return `You cannot do this right now!`
        let type = ''
        if(item[0] == 'h'){
            type = "Hacked "
        } else if(item[0] == 'f'){
            type = 'Failed '
        } else {
            type = ''
        }
        if(item.length == 5){
            item = item.slice(1);
        }
        
        let baseItem = item
        item = `${type}${switcher.StL[item]}`

        if(inventory[item]){
            if(inventory[item] == 0) delete inventory[item];
            inventory[item]--;
            if(inventory[item] == 0) delete inventory[item];
            let sellPrice = 0;
            if(type == 'Hacked '){
                partitionRecords += Math.round(shop[baseItem].price * 2);
                sellPrice = Math.round(shop[baseItem].price * 2);
            } else {
                partitionRecords += Math.round(shop[baseItem].price * 0.5);
                sellPrice = Math.round(shop[baseItem].price * 0.5);
            }
            lastSoldItem = item;
            return `Sold ${item} for ${sellPrice} Partition Record${sellPrice == 1 ? "" : 's'}.`
        } else {
            return `You do not have any ${item} to sell.`
        }
    }
    let cellIDs = []
    let hacking = false;
    let clickedCell = '';


    function hack(item){
        // check if the item is in the inventory
        if(inventory[switcher.StL[item]]){
            if(!hacking){
                let startTime = timeMeasuringTicks;
                paused = true;
                hacking = true;
                let correctOrder = true;
                truePaused = true;
                cellIDs = []
                for(i = 0; i < technicals[item].gridSize; i++){
                    for(j = 0; j < technicals[item].gridSize; j++){
                        let cell = document.createElement('div');
                        cell.id = `(${j},${i})`;
                        cellIDs.push(cell.id);
                        cell.style.border = '1px solid black';
                        cell.style.fontSize = '20px';

                        grid.setAttribute('style', `grid-template-columns: repeat(${technicals[item].gridSize}, ${500 / technicals[item].gridSize}px)`);

                        grid.appendChild(cell);
                    }
                }
                grid.removeAttribute('class');
                // add a click event listener to each cell


                let randomIndexes = [];
                while(randomIndexes.length < technicals[item].puzzleLength){
                    let randomIndex = Math.floor(Math.random() * cellIDs.length);
                    if(!randomIndexes.includes(cellIDs[randomIndex])){
                        randomIndexes.push(cellIDs[randomIndex]);
                    }
                }
                // insert the number order into the cells

                let clickedCells = [];
                // continuously check if the current time is greater than the start time + the time it takes to hack the item
                for(i = 0; i < randomIndexes.length; i++){
                    document.getElementById(randomIndexes[i]).innerHTML = i + 1;
                }
                grid.removeAttribute('class');
                removeFromInventory(switcher.StL[item])

                let timer = setInterval(() => {
                    timeLeft.removeAttribute('class');
                    timeLeft.innerHTML = `Time left: ${Math.round((technicals[item].timeLimit * 1000 / 125 - (timeMeasuringTicks - startTime)) * 125 / 1000)}`
                    if(technicals[item].timeLimit * 1000 / 125 <= timeMeasuringTicks - startTime){
                        paused = false;
                        hacking = false;
                        grid.setAttribute('class', 'hidden');
                        grid.innerHTML = '';
                        timeLeft.setAttribute('class', 'hidden');
                        timeLeft.innerHTML = '';
                        clearInterval(timer)
                        return console.log(`Failed to hack ${switcher.StL[item]}.`)
                    }
                }, 1)
                for(i = 0; i < cellIDs.length; i++){
                    document.getElementById(cellIDs[i]).addEventListener('click', () => {
                        truePaused = false;
                        for(i = 0; i < randomIndexes.length; i++){
                            document.getElementById(randomIndexes[i]).innerHTML = '';
                        }

                        clickedCells.push(event.target.id);
                        if(clickedCells.length == randomIndexes.length){
                            for(i = 0; i < randomIndexes.length; i++){
                                if(randomIndexes[i] == clickedCells[i]){
                                    correctOrder = true;
                                } else {
                                    paused = false;
                                    hacking = false;
                                    grid.setAttribute('class', 'hidden');
                                    grid.innerHTML = '';
                                    timeLeft.setAttribute('class', 'hidden');
                                    timeLeft.innerHTML = '';
                                    clearInterval(timer)
                                    return console.log(`Failed to hack ${switcher.StL[item]}.`)
                                }
                            }
                            if(correctOrder){
                                paused = false;
                                hacking = false;
                                grid.setAttribute('class', 'hidden');
                                grid.innerHTML = '';
                                timeLeft.setAttribute('class', 'hidden');
                                timeLeft.innerHTML = '';
                                addToInventory('Hacked ' + switcher.StL[item])
                                let time = Math.round((timeMeasuringTicks - startTime) * 125 / 1000)

                                currentExp += technicals[item].exp;
                                clearInterval(timer)
                                return console.log(`Successfully hacked ${switcher.StL[item]} in a time span of ${time} second${time == 1 ? '' : 's'}!`)
                            }
                        }
                    })
                }
            }

        } else {
            let status = ''
            if(item[0] == 'h' || item[0] == 'f'){
                status = item[0];
                item = item.slice(1);
                return `Cannot hack ${switcher.StL[status]} ${switcher.StL[item]}.`

            }
            return `You do not have any ${switcher.StL[item].replace('Partition', 'Partitions')}.`
        }
        return `Hacking ${switcher.StL[item]}...`
    }

    // convert ticks to seconds

    addToInventory('Unsecure Bitram Partition Mk. 1')
</script>