<style>
</style>
<head>

</head>
<body>
    <script src="./two.js"></script>
    <div id="stats">
    </div>
</body>
<script>

    let two = new Two({
        fullscreen: true,
        autostart: true
    }).appendTo(document.body);

    let hide = false;

    function getRectIntersect(Cx, Cy, w, h, Ax, Ay){
        let Px = Math.abs(Ax - Cx)
        let Py = Math.abs(Ay - Cy)

        // Slope of line from Point P to Center
        let Pm = Py / Px

        // Slope of rectangle Diagonal
        let Rm = h / w

        // If the point is inside the rectangle, return the center
        let res= [0, 0]

        // // Check if the point is inside and if so do not calculate
        // if (!(Px < w / 2 && Py < h / 2)) {

        // Calculate point in first quarter: Px >= 0 && Py >= 0
            if (Pm <= Rm) {
                res[0] = w / 2
                res[1] = (w * Pm) / 2
            } else {
                res[0] = h / (Pm * 2)
                res[1] = h / 2
            }

            // Set original sign 
            if (Ax - Cx < 0) res[0] *= -1
            if (Ay - Cy < 0) res[1] *= -1
        // }

        // Translate back
        return [res[0] + Cx, res[1] + Cy]
    }

    const bounceAmount = 4;

    let lines = []

    let yLine = two.makeLine(two.width / 2, 0, two.width / 2, two.height / 2);
    yLine.stroke = '#00ff00';
    yLine.linewidth = 3;

    let xLine = two.makeLine(0, two.height / 2, two.width / 2, two.height / 2);
    xLine.stroke = '#ff0000';
    xLine.linewidth = 3;

    let hypoLine = two.makeLine(xLine.vertices[0].x, xLine.vertices[0].y, yLine.vertices[0].x, yLine.vertices[0].y);
    hypoLine.stroke = '#0000ff';
    hypoLine.linewidth = 3;

    let maxXLine = two.makeLine(0, 0, 0, two.height);
    maxXLine.stroke = '#ff0000';

    let maxYLine = two.makeLine(0, 0, two.width, 0);
    maxYLine.stroke = '#00ff00';

    let maxHypoLine = two.makeLine(0, 0, two.width, two.height);
    maxHypoLine.stroke = '#0000ff';

    let center = two.makeCircle(two.width / 2, two.height / 2, 5);
    center.fill = '#000000';

    let borderSphere = two.makeCircle(0, 0, 2);
    borderSphere.fill = '#000000';
    borderSphere.noStroke();

    lines.push(maxHypoLine)

    if(hide){
        yLine.opacity = 0;
        xLine.opacity = 0;
        hypoLine.opacity = 0;
        maxXLine.opacity = 0;
        maxYLine.opacity = 0;
    }

    for(i = 0; i < bounceAmount; i++){
        let line = two.makeLine(0, 0, 0, 0);
        line.stroke = '#000000';
        lines.push(line);
    }


    for(i = 0; i < lines.length; i++){
        if(i == 0) continue;

        let prevLine = lines[i - 1];
        let line = lines[i];

        line.vertices[0].x = prevLine.vertices[1].x;
        line.vertices[0].y = prevLine.vertices[1].y;

        // rotate line so it is perpendicular to hypoLine
        let angle = Math.atan2(prevLine.vertices[1].y - prevLine.vertices[0].y, prevLine.vertices[1].x - prevLine.vertices[0].x);

        line.vertices[1].x = prevLine.vertices[1].x + Math.cos(angle) * 1000;
        line.vertices[1].y = prevLine.vertices[1].y - Math.sin(angle) * 1000;
    }

    document.body.addEventListener('mousemove', function (e) {
        yLine.vertices[0].y = e.clientY;
        xLine.vertices[0].x = e.clientX;

        hypoLine.vertices[0].x = yLine.vertices[0].x;
        hypoLine.vertices[0].y = yLine.vertices[0].y;
        hypoLine.vertices[1].x = xLine.vertices[0].x;
        hypoLine.vertices[1].y = xLine.vertices[0].y;

        maxXLine.vertices[0].x = xLine.vertices[0].x;
        maxXLine.vertices[1].x = xLine.vertices[0].x;

        maxYLine.vertices[0].y = yLine.vertices[0].y;
        maxYLine.vertices[1].y = yLine.vertices[0].y;

        maxHypoLine.vertices[0].x = center.translation.x;
        maxHypoLine.vertices[0].y = center.translation.y;

        // rotate maxHypoLine.vertices[1] so it is perpendicular to hypoLine
        let angle = Math.atan2(hypoLine.vertices[1].y - hypoLine.vertices[0].y, hypoLine.vertices[1].x - hypoLine.vertices[0].x);

        // get the distance from the center to the edge of the screen at the angle of hypoLine
        let distance = Math.sqrt(Math.pow(center.translation.x - two.width, 2) + Math.pow(center.translation.y - two.height, 2));

        maxHypoLine.vertices[1].x = center.translation.x + Math.cos(angle) * 1000;
        maxHypoLine.vertices[1].y = center.translation.y - Math.sin(angle) * 1000;

        let intersect = getRectIntersect(center.translation.x, center.translation.y, two.width, two.height, maxHypoLine.vertices[1].x, maxHypoLine.vertices[1].y);

        maxHypoLine.vertices[1].x = intersect[0];
        maxHypoLine.vertices[1].y = intersect[1];

        for(i = 0; i < lines.length; i++){
            if(i == 0) continue;
            let line = lines[i];
            let prevLine = lines[i - 1];
            let nextLine = lines[i + 1];

            line.vertices[0].x = prevLine.vertices[1].x;
            line.vertices[0].y = prevLine.vertices[1].y;

            let angle = Math.atan2(prevLine.vertices[1].y - prevLine.vertices[0].y, prevLine.vertices[1].x - prevLine.vertices[0].x);

            line.vertices[1].x = prevLine.vertices[1].x + Math.cos(angle) * 1000;
            line.vertices[1].y = prevLine.vertices[1].y - Math.sin(angle) * 1000;

            let intersect = getRectIntersect(center.translation.x, center.translation.y, two.width, two.height, line.vertices[1].x, line.vertices[1].y);
            let degAngle = angle * 180 / Math.PI;
            line.vertices[1].x = intersect[0];
            line.vertices[1].y = intersect[1];

            if(i == lines.length) continue
            else if(degAngle == 90 || degAngle == -90){
                let line = lines[i];
                let prevLine = lines[i - 1];

                prevLine.vertices[1].x = line.vertices[1].x;
                prevLine.vertices[1].y = line.vertices[1].y;
            }

        }
    });

</script>